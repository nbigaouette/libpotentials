/****************************************************************

    Routines for single photon ionization

    Important references:
        Tree code

****************************************************************/

#ifdef __SUNPRO_CC
#include <float.h>
#include <stdlib.h>
#include <stdio.h>
#include <limits.h>
#else
#include <cfloat>
#include <cstdlib>
#include <cstdio>
#include <climits>
#endif

#include <cassert>
#include <string.h>
#include <unistd.h>

#include "Constants.hpp"
#include "SinglePhoton.hpp"
#include "General.hpp"
#include "Potentials.hpp"
#include "Code_Functions_Declarations.hpp"
#include "Particles_Operations.hpp"
#include "Global.hpp"
#include "Auger.hpp"
#include "Std_Cout.hpp"

// const bool account_for_orbital_electrons = true;
// const bool account_for_orbital_electrons = false;
// const bool use_guidance = true;
const bool use_guidance = false;
// **************************************************************
// ********** Local functions prototypes ************************
// **************************************************************
double xsection_table_of_data(double photon_energy,const double Ip_au,const float data[][2], const int Nb_entries);
double Single_photon_fit(double E,const double *par);
double xsection_Xe(double photon_energy);
double xsection_Xe_2e(double photon_energy,const elem_props &element);
double Argon_photoXsection(int ion_cs, double photonE_au);
// **************************************************************
// ********** Accessible functions implementations **************
// **************************************************************

double Ionization_SinglePhoton(
        void *al, void *el,
        const int t, const double dt, const double time, const double tskip,
        const int &Nb_atoms, const int &Nb_atoms_max,
        int &Nb_electrons, const int &Nb_electrons_max,
        unsigned long int &index_next_empty_space,
        const elem_props &element, double laser_field[3], laser_props &laser,
        bool &did_ionization_occur,
        int *ionizedlist, Lib_PRNG &prng,
        FILE *fh_out,bool do_instantaneous_electron_screening)
/**
 * Test all atoms/ions to see if they ionize by single photon absorption.
 * @param al            Pointer to begining of atoms/ions list
 * @param el            Pointer to begining of electrons list
 * @param t             Time iteration
 * @param dt            Time step [s]
 * @param tskip         Pulse delay [s]
 * @param period        Period of calls to Ionization_Impact(). Ionization routines might not be
 *                      called at each time steps but with a certain period, resulting in
 *                      an equivalent time and time step scaled by this period.
 * @param Nb_atoms      Current number of atoms/ions in the list
 * @param Nb_atoms_max  Maximum number of atoms/ions in the list
 * @param Nb_electrons  Current number of electrons in the list
 * @param Nb_electrons_max          Maximum number of electrons in the list
 * @param index_next_empty_space    Next empty space in electrons' list index
 * @param element       Atoms/ions element properties
 * @param laser_field   Laser field value [V . m^-1]
 * @param laser         Laser properties
 * @param did_ionization_occur      Did ionization occured in this function?
 * @param ionizedlist   List of ions Ids which ionized here
 * @param fh_out        File handle where output should be made. Note that the file
 *                      should already be opened by the calling conde. Default to NULL.
 * @return              Returns "delta_energy" [J], the change in energy due to
 *                      the configuration change if ionization occured. This should
 *                      be equal to the photon energy minus the Ip of the ionized ion.
 */
{
    //static const int oe_size = Get_orbiting_electrons_Size();

    static double number_photons = -2.0;
    static double cluster_area;
    static double omega_laser;

    static int core_photons=0; //the  number of photons used to excite the core
    static int core_atoms=0;   //the id's of the core atoms

    // Return value. Before the electron is created, there is
    // a "hidden" energy component in its bounding with its
    // parent ion: the Ip. This value keeps track of the
    // change in the total energy measured.
    double delta_energy = 0.0;

    void *nce = NULL;                   // Newly created electron (if any)
    void *nce2 = NULL;                  // Second newly created electron (if any)
    void *ion = NULL;                   // Parent ion to nce

    int orig_did_ionization_occur = did_ionization_occur;

    const int oe_size = Get_orbiting_electrons_Size();
    if ((oe_size > 0) && do_instantaneous_electron_screening) { std_cout << "Can't do IES and avergaed MT\naborting\n";abort();}
    int **ions_w_classical_electrons = NULL;
    if ((oe_size > 0) || do_instantaneous_electron_screening)
    {
        ions_w_classical_electrons = Find_Classical_Electrons(al, el, t, Nb_atoms, Nb_atoms_max, Nb_electrons, Nb_electrons_max);
    }

// #ifdef PHOTOOUT
//     char single_photon_file_name[1000+1];
//     FILE *single_photon_file = NULL;
//     sprintf(single_photon_file_name,  "%s/%s", Lib_Get_IOBasename(), "singlephoton.log");
//     if(Lib_Get_Rank() == 0)
//     {
//       if (t == 0)
//       {
//             // Make sure the file is cleared
//         single_photon_file = fopen(single_photon_file_name,"w");
//         fclose(single_photon_file);
//       }
//       single_photon_file = fopen(single_photon_file_name,"a");
//       if ( single_photon_file == NULL )
//       {
//         DEBUGP("ERROR in library!!!\n");
//         fprintf(stderr, "Can't open file %s\n", single_photon_file_name);
//         getchar();
//         abort();
//       }
//     }
// #endif /* #ifdef PHOTOOUT */



    if (number_photons < -1.99999999)
    {
        // If the laser structure has a value for the number of photons (which would have been set in the code)
        // then take this value instead. This allows saving snapshots and restoring them. Treecode memset() the laser
        // structure to 0 and don't set the nb_photons, so this will never be used with the treecode.
        //if (laser.nb_photons != 0.0)
        if (laser.nb_photons > 1.0e-3)
        {
            std_cout << "Setting the nb of photons to: laser.nb_photons = " << laser.nb_photons << "\n";
            number_photons = laser.nb_photons;
        }
        else
        {
            // Else, calculate the number of photons impinging the cluster
            double cluster_radius;

            if (Nb_atoms == 1)
            {
                std_cout << "Only one atom: radius will be null. Setting it to 2 Angstrom...\n";
                cluster_radius = 2.0 * angstrom_to_m;
            }
            else
            {
                // Find cluster radius by taking the furthest atom.
                double r2_max = 0.0;
                double r2_tmp = 0.0;
                for (int i = 1 ; i < Nb_atoms_max ; i++)
                {
                    r2_tmp = Vector_Length(Get_Position(get_voidp(al, i)));
                    if (r2_tmp > r2_max)
                        r2_max = r2_tmp;
                }
                cluster_radius = sqrt(r2_tmp);
            }

            cluster_area = Pi * cluster_radius * cluster_radius;

            // This is omega from a laser with I=I_0 sin^4(omega t)
            // => 1/2 = sin^4 (omega*t_max -omega*delta t)  where delta t =time from peak to I_0/2
            // omega*t_max = Pi/2  and delta T is hwhm or 1/2 fwhm
            // =>1/2 = sin^4 (Pi/2 -omega*1/2*fwhm)= cos^4(omega*fwhm/2)
            omega_laser = 2.0*acos(pow(0.5,0.25))/laser.fwhm;

            number_photons =
                  (three_over_eight*Pi/omega_laser)     // Integral over sin^4(omega_1 t) [mks]
                * (cluster_area/(hbar*laser.ww))        // Relevant area of the whole beam divided by photon energy [mks]
                * (laser.intensity/ cm_to_m/cm_to_m);   // Laser intensity in m^2 matching cluster_area [mks]

            std_cout << "\nLIB: There are " << number_photons << " photons impinging on the cluser of : radius = " << cluster_radius * m_to_nm << " nm, diameter = " << 2.0 * cluster_radius * m_to_nm << " nm, area = " << cluster_area * m_to_nm * m_to_nm << " nm^2\n";

            if (use_guidance)
            {
                core_photons = int(number_photons*0.4);
                core_atoms   = int(floor(double(core_photons/2))*0.8);
            }
            else
            { //make conditions that will always succeed
                core_photons = INT_MAX;
                core_atoms = INT_MAX;
            }

            // Make sure the laser structure contains the photon number in case of snapshots
            laser.nb_photons = number_photons;
        }
    }

    if ( number_photons > 1.0 &&                // Are there any photon left?
        time+tskip <= Pi/omega_laser ) // Is laser still on?
    {                                           // period/2 =T/2 = Pi/omega

        //The number of photons times I_0_const gives laser.intensity
        //as the number of photons decreases this will decrease the
        //probability of photoionization
        static const double I_0_const = ( (hbar * laser.ww) / cluster_area )
                                      * ( eight_over_three * omega_laser / Pi);
        //flag to allow photoionization to take place wo using  muffin-tin
        bool remove_energy_from_orbital_e = false;


        for (int i = 0 ; i < Nb_atoms ; i++)
        {
            ion = get_voidp(al, i);

            const int ion_id = Get_Id(ion);

//             if ((number_photons >12)  && (ion_id>7 ) ) continue;
            //if ((number_photons >34)  && (ion_id> 20) ) continue;

//            if ((number_photons <core_photons)  || (ion_id<core_atoms ) )
            {

            // If ionization is allowed
            if (t >= 0*Get_NextIon(ion))
            {
                remove_energy_from_orbital_e = false;
                const int ion_cs = Get_Charge_State(ion);

                assert(ion_cs >= 0);

                // Muffin_Tin_Correction_To_Ip_au() returns 0 if <n> == 0
                double Ip_au_correction   = -Muffin_Tin_Correction_To_Ip_au(ion);  // [Hartree]
                int num_clasical_orbiting_el = 0;
                if (do_instantaneous_electron_screening){
                  // Count classically orbiting electrons
                  if (ions_w_classical_electrons[ion_id] != NULL)
                    num_clasical_orbiting_el = ions_w_classical_electrons[ion_id][0];

                  if (num_clasical_orbiting_el > 0){
                    // Remove the orbiting electrons from the potential at the ion
                    const double Pot_WIon_DOrbitingE = Get_Potential_From_Orbiting_Electrons(
                                                ion, al, ions_w_classical_electrons[ion_id],
                                                element, -1);

                    //Set the V_b level to where it is with the classically orbiting electrons
                    Ip_au_correction    = -Pot_WIon_DOrbitingE *eV_to_Eh;             // [Hartree]
                  } else {
                    Ip_au_correction = 0.0;
                  }
                }

                //const double Ip_au_correction = 0.0;
                double Ip_au              = (element.IpsLowest[ion_cs] * eV_to_Eh) + Ip_au_correction;
                double Ip                 = Eh_to_J * Ip_au;                          // [J]
                const double gamma = laser.pho_engy_au * Eh_to_J;
                // If the classically orbiting electrons can reduce the Ip, then they
                // should have enough kinetic energy to pay for this reduction.
                // The "-1" is the Id of an electron to skip (-1 means include them all)
                double K_OrbitingE = 0.0;
                if ((oe_size > 0) || (do_instantaneous_electron_screening))
                {
                    remove_energy_from_orbital_e = true;

                    //std_cout << "oe_size > 0!!!\n";
                    K_OrbitingE = Get_Total_Kinetic_Energy_of_Orbiting_Electrons(al, ions_w_classical_electrons[ion_id], -1);
                    if ((K_OrbitingE < Eh_to_J*Ip_au_correction) && (gamma < element.IpsLowest[ion_cs] * eV_to_J))
                    {
//                        std_cout << "Skipping K_OrbitingE\n";
                        continue;
                    }
                    // If the reaction can happen wo screening try it
                    else if (K_OrbitingE < Eh_to_J*Ip_au_correction)
                    {
                      remove_energy_from_orbital_e = false;
                      Ip_au_correction = 0.0;
                      Ip_au = (element.IpsLowest[ion_cs] * eV_to_Eh);
                      Ip    = Ip_au*Eh_to_J;
                    }
                    //ONLY for diagnostics
/*                    else if (Ip_au_correction !=0.0) { //the correction will be used!
                      std_cout << "SP.Ip_correction_au=" << Ip_au_correction << "\n";
                    }*/
                }


                //ensure the Ip must never be negative
                if (Ip < 0.0) {
                  Ip = 0.0;
                  Ip_au_correction = -element.IpsLowest[ion_cs] * eV_to_Eh;
                }

                //If this is Xenon in the area of the 4d resonance use this pohotoionization
                if (laser.la <30e-9 && element.atomicNumber == 54){
                  photoionization_Xe_4d(ion,al,el,
                                   Nb_atoms, Nb_atoms_max,Nb_electrons_max,oe_size,
                                   remove_energy_from_orbital_e,
                                   time, dt, tskip, Ip_au_correction, gamma, K_OrbitingE,
                                   ions_w_classical_electrons,laser_field,
                                   sin(omega_laser*t*dt),I_0_const,omega_laser,cluster_area,
                                   index_next_empty_space, Nb_electrons,did_ionization_occur, element,
                                   number_photons, delta_energy, laser,ionizedlist, prng,fh_out );
                } else {
                // If laser photon energy is more than ionization potential
                if (gamma >= Ip)
                {

                    const double Eabs = Vector_Length(laser_field); // |E|   [V . m^-1]

                    if (Eabs > DBL_MIN)
                    {
                      double wspi = Ionization_Rate_SinglePhoton(Ip_au,
                                                    laser.pho_engy_au,
                                                    ion_cs,element,omega_laser,
                                                    number_photons,I_0_const,(double) t*dt+tskip)
                                                    /cluster_area;
                      double wspi_2e = 0.0;
                      double photon_e_eff_au =  laser.pho_engy_au+ (element.IpsLowest[0]*eV_to_Eh- Ip_au );
                      //Test for the possibility of double ionization
                      if (((ion_cs == 0) && ( photon_e_eff_au >  element.IpsLowest[0]*eV_to_Eh + element.IpsLowest[1]*eV_to_Eh))
                            && (element.atomicNumber == 54) )
                      {
                             wspi_2e = Ionization_Rate_SinglePhoton_2e(Ip_au,
                                                    laser.pho_engy_au,
                                                    ion_cs,element,omega_laser,
                                                    number_photons,I_0_const,(double) t*dt+tskip)
                                                    /cluster_area;
                      }

                      double delta_qq = 1.0 - exp(-(wspi+wspi_2e)*dt);

                      double rand_nmb = prng.Get_Random();

                      // Monte-Carlo test for ionization
                      if (rand_nmb <= delta_qq)
                      {
                        //Now to determine is single or double ionization takes place
                        // First Get the proportion of double to single ionization
                        double proportion_2e = wspi_2e/(wspi_2e+wspi);
                        //make a decision of double ionization can occur
                        if (wspi_2e > 0.0){
                           rand_nmb = prng.Get_Random();
                        }
                        // ********************************************* test if double ionization can occur*********************************************
                        if ((wspi_2e > 0.0) && (rand_nmb < proportion_2e)){
                          std_cout << "single photon double ionization occured ("<<ion_cs<<"+ --> "<<ion_cs+2<<")  Id = " << Get_Id(ion) << "\n";
                          if (Ip_au_correction !=0.0) std_cout << "SP.Ip_correction_au=" << Ip_au_correction << "\n";
                          // The ion-electron system has an intrisinct energy: the Ip.
                          // This energy "disappear" in the code. We also have a net gain
                          // of the energy of the photon.
                          // We return this value so the code can keep track of it.
                          // Ip takes into account the lowering of the energy
                          //due to the muffin tin.
                          delta_energy += gamma - element.IpsLowest[0]*eV_to_J - element.IpsLowest[1]*eV_to_J+Ip_au_correction*Eh_to_J;
                          number_photons   -= 1.0;
                          laser.nb_photons -= 1.0;
                          nce = get_voidp(el, index_next_empty_space);

                          Create_Electron(
                              el, ion,
                              time,
                              Nb_atoms, Nb_atoms_max,
                              Nb_electrons, Nb_electrons_max,
                              index_next_empty_space,
                              element,
                              "Called from Ionization_SinglePhoton() in library"
                          );

                          nce2 = get_voidp(el, index_next_empty_space);

                          Create_Electron(
                              el, ion,
                              time,
                              Nb_atoms, Nb_atoms_max,
                              Nb_electrons, Nb_electrons_max,
                              index_next_empty_space,
                              element,
                              "Called from Ionization_SinglePhoton() in library"
                          );

                          //set the position of the 1st electron
                          for (int d = 0 ; d < 3 ; d++) Get_Position(nce)[d] = Get_Position(ion)[d]+electron_creation_distance* (laser_field[d]/Eabs);
                          //set the position of the 2nd electron
                          for (int d = 0 ; d < 3 ; d++) Get_Position(nce2)[d] = Get_Position(ion)[d]-electron_creation_distance* (laser_field[d]/Eabs);


                          // Potential energy between the 1st new electron and its parent ion (with updated charge)
                          potential_paramaters potparams;
                          Potentials_Set_Parameters(nce, ion, element, potparams);
                          double U1f     = (-e0) * Calculate_Potential(nce, ion, element, potparams);
                          // add the potential due to the 2nd new electron to find the total
                          Potentials_Set_Parameters(nce, nce2, element, potparams);
                          U1f     +=       (-e0) * Calculate_Potential(nce, nce2, element, potparams);

                          // The potential energy is calculated by bringing one particle to the location
                          //from infinity at a time. The 1st would see a 2+, the second a (total of) 1+.
                          //Thus they would end up with different potential energies
                          //depite being in a symmetric state. So the energy must be divided equally
                          //amongst them. Thus nce which is viewed as the second particle brought from
                          //infinity (since it measures the pot of nce2 which is already there), nce
                          //needs to gain 50% more potential energy, thus *=1.5.
                          U1f *=1.5;

                          // Potential energy between the 2nd new electron and its parent ion (with updated charge)
                          // and the 1st new electron is exactly the same
                          const double U2f     =  U1f;

                          //calculate the KE to split amongst the 2 electrons
                          //it is split randomly as per fig 2 of doc/singlephoton/Eland_Two_electron_spectra_double_photionization.pdf
                          const double total_KE = (gamma - Ip)- element.IpsLowest[1]*eV_to_J;
                          rand_nmb = prng.Get_Random();
                          const double nce_K    = rand_nmb*total_KE       - U1f;
                          const double nce_vel  = sqrt(2.0 * nce_K / me);
                          const double nce2_K   = (1.0-rand_nmb)*total_KE - U2f;
                          const double nce2_vel = sqrt(2.0 * nce2_K / me);


                          // Choose randomly the direction of the new electron's velocity by it's position
                          double E_unit[3];
                          for (int d = 0 ; d < 3 ; d++) E_unit[d] = laser_field[d] / Eabs;
                          //assign the velocity to the 1st electron
                          for (int d = 0 ; d < 3 ; d++) Get_Velocity(nce)[d]  =  nce_vel  * E_unit[d];
                          //assign the velocity to the 2nd electron
                          for (int d = 0 ; d < 3 ; d++) Get_Velocity(nce2)[d] = -nce2_vel * E_unit[d];

                          // ************ conserve momentum ***********************
                          //They are added since Get_Velocity(nce2) < 0  and Get_Velocity(nce) >0
                          for (int d = 0 ; d < 3 ; d++) Get_Velocity(ion)[d] -= me*(Get_Velocity(nce)[d] + Get_Velocity(nce2)[d] )/Get_Mass(ion);
                          //add the photon momentum to the ion
//                           const double photon_momentum_energy            = hbar*co/laser.la;
//                           const double ion_velocity_from_photon_momentum = photon_momentum_energy/Get_mass(ion);

                          // ******************************************************
                          // Since each classically orbiting electrons have shielded
                          // the ion and lowered the Ip via Ip_correction, they need
                          // to pay to balance the energy.
                          if ((oe_size > 0) && (ions_w_classical_electrons[ion_id] != NULL)
                               && remove_energy_from_orbital_e
                             )
                          {
                              Remove_IpCorrection_From_Orbiting_Electrons(al, ions_w_classical_electrons[ion_id],
                                                                           Eh_to_J*Ip_au_correction, K_OrbitingE, -1);
                          }



                          // The ion cannot be ionized for dt=hbar/dE
                          // where dE is the transition energy (photon energy)
                          //  int next_ion = t ;//+ (int)ceil((hbar / gamma) / dt);
                          //  if( next_ion > Get_NextIon(ion) ) Set_NextIon(ion, next_ion);

                          // Save to passed file handle
                          if(Lib_Get_Rank() == 0)
                          {
                              if (fh_out != NULL)
                              {
                                // Get_Excited_State_index(ion) is saved to have simimlar output as Impact.cpp
                                fprintf(fh_out, "%.15g, %2d, %2d, %7d, %7d, %7d, %10.8g, %10.8g, %4d, %4d\n",
                                                  time*s_to_fs,
                                                         IONIZATION_PROCESS_SINGLE_DOUBLE,
                                                              Get_Charge_State(ion),
                                                                   Get_Id(ion),
                                                                       Get_Id(nce),
                                                                           -1,
                                                                               total_KE*J_to_Eh,
                                                                                      Ip_au_correction,
                                                                                             Get_Excited_State_index(ion),
                                                                                                 Get_Id(nce2));
                                  fflush(fh_out);
                              }
                          }

                          ionizedlist[0]++;
                          ionizedlist[Get_Id(ion) + 1] = Get_Id(ion);
                          did_ionization_occur = true;
                        }
                        // ********************************************* single photon ionization *********************************************
                        else
                        {
                           do_a_single_photon_ionization(ion,al,el,
                                                         ion_id, ion_cs, time,
                                                         Nb_atoms,Nb_atoms_max,Nb_electrons_max,oe_size,
                                                         remove_energy_from_orbital_e,
                                                         Ip_au_correction, gamma,Ip, K_OrbitingE,
                                                         ions_w_classical_electrons, laser_field,
                                                         index_next_empty_space, Nb_electrons,element,
                                                         number_photons, delta_energy, laser,prng,
                                                         IONIZATION_PROCESS_SINGLE, fh_out );

                          ionizedlist[0]++;
                          ionizedlist[Get_Id(ion) + 1] = Get_Id(ion);
                          did_ionization_occur = true;
                        } // if (rand_nmb <= delta_qq)
                        } // if ((wspi_2e > 0.0) && (rand_nmb < proportion_2e))
                      } // if (Eabs > DBL_MIN)
                  } // if (Ip_au > DBL_MIN && Ip_au <= laser.pho_engy_au)
              }//if(laser.la <30e-9 && element.atomicNumber == 54)
              } // if (t >= Nextion(ion))
              }//if using guided and guided conditions
          } // for (void *ion = al ; ion < al + Nb_atoms ; ion++)
      }

// #ifdef PHOTOOUT
  //     fclose(single_photon_file);
  // #endif
      //If another type of ionizationed happened make sure the
      //did_ionization_occur flag is set properly
      //by ORing with the initial value of the flag
      did_ionization_occur = (did_ionization_occur || orig_did_ionization_occur);

      return delta_energy;
  }

  // **************************************************************
  double Single_photon_fit(double E,const double *par)
/**
   * The fit function used to fit the Xsection of Xe's 5P->S or D
   * par[] is an array of the parameters in alphabetical order, E
 * is the photoelectron energy = h*c/lambda-Ip
   */
  {
      return (
            par[0] * exp(-E*par[1])
          + par[2] * pow( E,par[3])
          + par[4] * pow( E,par[5])
    );
  }


  // **************************************************************
  double Ionization_Rate_SinglePhoton(const double Ip_au,
                                      const double Ephoton_au,
                                      const int ion_charge,
                                      const elem_props &element,
                                      const double omega_l,
                                    const double num_photons,
                                      const double I_0_const,
                                      const double time
  )
  /**
   * Returns in  MKS units for the rate
   * Cross-sections (xsec and xsecS_P) are calculated in atomis units (bohr^2)
   * Atomic Photoeffect. M. Ya. Amusia, Plenum Press, 1990
   * Equation (3.53), page 68
   *
   *
   * New version NOTE: fits are only good for photoelectron energies < 81.6 eV
 */
{

      // Original version using the Formula from Amusia for the
      // ground state of hydrogen and small photoelectron energy
      double wspi = 0.0;

    // A fit of the Xsection where a Herman-Skillman potential
    // was used to obtain the wavefunctions (using the Mapped
   // Fourier grid method) for the bound and continuum states
   // and the integrals were done numerically. The resulting
   // Xsection for S and D continuum final state electrons from
   // a bound 5P state (Xe) was fitted using:
   //    f(x)=a*exp(-x*b)+c*x**d+f*x**g

   const double sin_omega_t = sin(omega_l*time);

   //for Argon do this
   if ((element.atomicNumber == 18) && (ion_charge < 2)){
     return (num_photons * 8.0*omega_l/(3.0*Pi) * ( Argon_photoXsection(ion_charge,Ephoton_au) )
                * sin_omega_t * sin_omega_t * sin_omega_t * sin_omega_t);
   } else if (element.atomicNumber == 18){
     //don't try and photoionize higher charge states as the data is not there
     return 0.0;
   } else if (element.atomicNumber == 54){


     //if this is an atom use the interpolated experimental data
     //see doc/singlephoton/West1978_Xe_photo_ionization_Xsection.pdf
     if (ion_charge == 0){
        //The interpolation is done is abolute photon energy in eV
          //With muffin tin the Ip is lowered. This is used here as a
          // more energetic photon. Thus we add the Ip_correction of the
          //muffin tin (0 in the case of no muffin tin).
          const double photon_energy_au =  Ephoton_au+ (element.IpsLowest[0]*eV_to_Eh- Ip_au );
          const double atom_xsection_m2 = xsection_Xe( photon_energy_au)*a0*a0;
  //     std_cout << "Ephoton_au="<<Ephoton_au<<" ele.Ip="<<element.IpsLowest[ion_charge]*eV_to_Eh<<" Ip_au=%g Xsec="<<Ip_au,atom_xsection_m2<<"\n";
    //       return atom_xsection ;
  //         std_cout << "xsec="<<atom_xsection_m2<<"  wspi="<<num_photons * 8.0*omega_l/(3.0*Pi) *atom_xsection_m2* sin_omega_t * sin_omega_t * sin_omega_t * sin_omega_t<<"\n";
  //        return num_photons * I_0_const *atom_xsection* sin_omega_t * sin_omega_t * sin_omega_t * sin_omega_t;
         return num_photons * 8.0*omega_l/(3.0*Pi) *atom_xsection_m2* sin_omega_t * sin_omega_t * sin_omega_t * sin_omega_t;
        }

        // ********** See PRA 74 043204 Eq (4) for the expression ***
     // Constants of the expression
     //xsecS_P is the cross section for 5S to P states
     double xsecS_P = (2.0*two_over_three)*Pi*Pi*alpha*Ephoton_au;
     double xsec    = (2.0*two_over_three)*Pi*Pi*alpha*Ephoton_au;

     // Multiply by the specific l-dependent constants
     if (ion_charge < 6) xsec *= one_over_three;   // 1 / (2 * l_i + 1)
        //else it is an S electron and the factor is 1

        // Use different fit parameters depending on the photoelectron energy
      double photoe_En = Ephoton_au-Ip_au; // Photoelectron energy in au
      //The fits of the Xsection don't work near E=0 so use E=1e-3 (error < 1%)
      const double toosmall = 2e-3;
      if (photoe_En < toosmall){
          //std_cout << "too small photoe_En=" << photoe_En << "\n";
          photoe_En = toosmall;
      }

      double radial_ints=0.0;
      // Fit for charge > 6+ was not done, so just use the hydrogen approx
      if (ion_charge > 6)
      {
          xsec = 0.23 * (1.0 - eight_over_three*(Ephoton_au - Ip_au)/Ip_au);
          wspi = num_photons * I_0_const * xsec
                    * sin_omega_t * sin_omega_t * sin_omega_t * sin_omega_t;
      }
      else // if (ion_charge > 6)
      {
          // Add the integrals contribution
          if      (photoe_En <  fit_Xe_photo_lt_R1[ion_charge][7])
              radial_ints = Single_photon_fit(photoe_En, fit_Xe_photo_lt_R1[ion_charge]);
          else if (photoe_En <= fit_Xe_photo_lt_R2[ion_charge][7])
              radial_ints = Single_photon_fit(photoe_En, fit_Xe_photo_lt_R2[ion_charge]);
          else
              radial_ints = Single_photon_fit(photoe_En, fit_Xe_photo_lt_R3[ion_charge]);

          // Obtain the Xsection by multiplying the results of the
          // radial integrals with the constants
          // 6 is for the 6-P electrons in the shell (q in PRA 74 043204)
          if (ion_charge < 6)
          xsec *= (6.0-ion_charge) * radial_ints;
          else
          xsec *= 2.0* radial_ints; //2.0 == 2 S electrons

          // Photon energy above the S->P transition
          double photoe_En_S = Ephoton_au - (
              // 5S (n = 5 = max, l = 0)
              element.Ips[get_element_index(0, element.max_n, ion_charge, element.max_l, element.max_n)]
              //lower the Ip the same amount as for the P (barrier lowering)
              - (
                  // 5P (n = 5 = max, l = 1)
                 element.Ips[get_element_index(1, element.max_n, ion_charge, element.max_l, element.max_n)]
                 - Ip_au
              )
          )*eV_to_Eh;

          // If the energy is between 0 and toosmall take it as constant since
          // the fits aren't good near the origin
          if ( (photoe_En_S < toosmall) && (photoe_En_S > 0.0) )
          {
              photoe_En_S = toosmall;
          }

          // Is the S state an inner electron, if yes add its cross-section
          if ( (ion_charge < 6) && (photoe_En_S > 0.0) )
          {
              // Can an inner 5S be ionized (2.0 is for the two electrons)
              if      (photoe_En_S <  fit_Xe_5S_photo_lt_R1[ion_charge][7])
                  xsecS_P *= 2.0 * Single_photon_fit(photoe_En_S, fit_Xe_5S_photo_lt_R1[ion_charge]);
              else if (photoe_En_S <= fit_Xe_5S_photo_lt_R2[ion_charge][7])
                  xsecS_P *= 2.0 * Single_photon_fit(photoe_En_S, fit_Xe_5S_photo_lt_R2[ion_charge]);
              else if (photoe_En_S <= fit_Xe_5S_photo_lt_R3[ion_charge][7])
                  xsecS_P *= 2.0 * Single_photon_fit(photoe_En_S, fit_Xe_5S_photo_lt_R3[ion_charge]);
              else
                  xsecS_P *= 2.0 * Single_photon_fit(photoe_En_S, fit_Xe_5S_photo_lt_R4[ion_charge]);
          }
          else
          {
              // The ion is >5+ so there are only S states so xsecS_P is redundant
            xsecS_P = 0.0;
          }

           /*        wspi = num_photons * I_0_const * (xsec + xsecS_P)
                * sin_omega_t * sin_omega_t * sin_omega_t * sin_omega_t;*/
          //         std_cout << "xsec="<<xsec<<"  "<<ion_charge<<"\n";
          wspi = num_photons * 8.0*omega_l/(3.0*Pi) * (xsec + xsecS_P)*a0*a0
                * sin_omega_t * sin_omega_t * sin_omega_t * sin_omega_t;
      }
    }  //end if atomic number is 54 i.e. Xe

  return wspi;
}


/**
 * A function to use the experimental data from doc/singlephoton/West1978_Xe_photo_ionization_Xsection.pdf
 * to get an accurate cross-section for neutral Xe.
 * Units: lt_xsec_Xe[i][0] is in eV and the Xsection lt_xsec_Xe[i][1] is in Mb
 * @param  photon_energy energy of the photon in Hartree
 * @return the cross-section in atomic units
 */
double xsection_Xe(double photon_energy){

//taken from doc/singlephoton/Xe_exp_data_for_single_photon_from_WEST78.txt
//only included upto 100eV the file has more if needed
double lt_xsec_Xe[Nb_entries_Xe_photo_ionization][2]= {
  {13.45,66.30},
  {13.48,66.20},
  {13.62,65.72},
  {13.78,65.22},
  {13.93,64.69},
  {14.09,64.13},
  {14.25,63.53},
  {14.42,62.88},
  {14.59,62.19},
  {14.76,61.45},
  {14.94,60.67},
  {15.12,59.83},
  {15.31,58.94},
  {15.5,58.00 },
  {15.69,57.01},
  {15.89,55.96},
  {16.1,54.87 },
  {16.31,53.74},
  {16.53,52.55},
  {16.75,51.32},
  {16.98,50.05},
  {17.22,48.75},
  {17.46,47.40},
  {17.71,46.03},
  {17.97,44.62},
  {18.23,43.19},
  {18.50,41.73},
  {18.78,40.25},
  {19.07,38.76},
  {19.37,37.26},
  {19.68,35.75},
  {20.0,34.23 },
  {20.32,32.71},
  {20.66,31.20},
  {21.01,29.69},
  {21.38,28.19},
  {21.75,26.71},
  {22.14,25.24},
  {22.54,23.79},
  {22.96,22.37},
  {23.39,20.98},
  {23.84,19.61},
  {24.31,18.27},
  {24.80,16.98},
  {25.30,15.72},
  {25.83,14.51},
  {26.38,13.33},
  {26.95,12.21},
  {27.55,11.13},
  {28.18,10.10},
  {28.83,9.124},
  {29.52,8.201},
  {30.24,7.332},
  {30.99,6.519},
  {31.79,5.762},
  {32.63,5.064},
  {33.51,4.425},
  {34.44,3.845},
  {35.42,3.406},
  {36.46,3.038},
  {37.57,2.727},
  {38.74,2.444},
  {39.99,2.205},
  {41.33,2.004},
  {42.75,1.855},
  {44.28,1.731},
  {45.92,1.656},
  {47.68,1.591},
  {49.59,1.56 },
  {51.66,1.524},
  {53.90,1.519},
  {56.35,1.551},
  {59.04,1.673},
  {61.99,1.995},
  {65.25,2.658},
  {68.88,3.88 },
  {72.93,6.009},
  {77.49,9.266},
  {79.99,11.97},
  {82.65,15.27},
  {85.50,18.785},
  {88.56,22.04},
  {91.84,24.71},
  {95.37,26.49},
  {99.18,27.07}
};

  double gamma = photon_energy*Eh_to_eV;
  short int i=0;
  //find the energy above gamma
  for(i=0; ( float(gamma) > lt_xsec_Xe[i][0]) && (i < Nb_entries_Xe_photo_ionization);i++);

  //If it is really close to the threshold just use the 1st value
  if (i==0) return lt_xsec_Xe[0][1]*Mb_to_atomic_area;
  if (i==Nb_entries_Xe_photo_ionization){
   std_cout << "Photon too energetic, ran out of experimental data in xsection_Xe (SinglePhoton.cpp)\n";
   abort();
  }

  const short int index_above = (short int) i;
  const short int index_below = (short int) i-1;
  //linearly interpolate between the above and below points
  const float dx = (float) lt_xsec_Xe[index_above][0] - lt_xsec_Xe[index_below][0];
  const float dy = (float) lt_xsec_Xe[index_above][1] - lt_xsec_Xe[index_below][1];
  const double slope = (double) dy/dx;
  const double intercept = (double) lt_xsec_Xe[index_above][1] - slope*lt_xsec_Xe[index_above][0];


  //return in bohr squared. Mb * (0.01 cm/m)^2 / ( a0 m/bohr)^2
  return (double) (slope*gamma+intercept)*Mb_to_atomic_area;
}


/**
 * A function to return the cross-section (in Bohr^2)
 * of single photon double ionization taken from experimental data
 * @param photon_energy The energy of the photon in Hartree
 * @param element The element under examination. It only works
 *                for Xe but if the input file changes the Ips
 *                the threshold here will automatically change,
 *                by passing the element's properties.
 * @return The cross section in atomic units (Bohr^2)
 */
double xsection_Xe_2e(double photon_energy,const elem_props &element){

  //Test if the photon is energetic enogh to do single photon double ionization
  if (photon_energy < (element.IpsLowest[0]+element.IpsLowest[1])*eV_to_Eh ) return 0.0;

float lt_Xe_photo2e[Nb_entries_Xe_2e_photo_ionization][2]={
  {32.921,0.0674964},
  {33.2629,0.132574},
  {33.5623,0.184628},
  {34.3377,0.230007},
  {34.8073,0.327638},
  {35.2372,0.366611},
  {36.097,0.444558 },
  {37.0476,0.450767},
  {38.1716,0.4504  },
  {39.2091,0.450062},
  {40.5492,0.449625},
  {41.7596,0.449231},
  {42.797,0.448893 },
  {43.662,0.442092 },
  {44.9585,0.448188},
  {46.385,0.447723 },
  {47.2928,0.447427},
  {48.4596,0.453566},
  {49.3242,0.453284},
  {50.1455,0.453016},
  {51.2698,0.446131},
  {52.6095,0.452213},
  {53.6898,0.45838 },
  {54.5112,0.458112},
  {55.4622,0.457802},
  {56.5001,0.450945},
  {57.1485,0.450734},
  {57.9695,0.456985},
  {58.9641,0.450142},
  {60.0012,0.456323},
  {60.8654,0.46256 },
  {62.0329,0.455661},
  {63.2429,0.461785},
  {64.1511,0.45497 },
  {64.8789,0.572073},
  {65.3049,0.676237},
  {65.5587,0.767419},
  {65.8983,0.871611},
  {66.1093,0.956288},
  {66.4908,1.08002 },
  {66.872,1.21028  },
  {67.2944,1.37311 },
  {67.5911,1.4708  },
  {67.8446,1.5685  },
  {68.0552,1.6597  },
  {68.309,1.75088  },
  {68.6041,1.87464 },
  {68.8128,1.99843 },
  {69.1087,2.10916 },
  {69.2745,2.22644 },
  {69.5283,2.31762 },
  {69.6953,2.41535 },
  {69.9052,2.51959 },
  {70.1162,2.60426 },
  {70.2828,2.70851 },
  {70.4061,2.81278 },
  {70.5303,2.904   },
  {70.7409,2.9952  },
  {70.8655,3.0799  },
  {71.0345,3.14503 },
  {71.0729,3.22325 },
  {71.1979,3.30143 },
  {71.3225,3.38614 },
  {71.6168,3.52294 },
  {71.9063,3.73797 },
  {72.1134,3.88784 },
  {72.2792,4.00512 },
  {72.4891,4.10936 },
  {72.6124,4.21362 },
  {72.7806,4.29179 },
  {72.9024,4.42213 },
  {73.1507,4.60458 },
  {73.4454,4.73486 },
  {73.5668,4.87172 },
  {73.8167,5.02809 },
  {73.9833,5.13234 },
  {74.1896,5.29524 },
  {74.3963,5.45163 },
  {74.6049,5.57542 },
  {74.7704,5.69923 },
  {74.9794,5.8165  },
  {75.1456,5.92727 },
  {75.3114,6.04455 },
  {75.4784,6.14228 },
  {75.6431,6.27913 },
  {75.8081,6.40945 },
  {75.9766,6.4811  },
  {76.1012,6.56581 },
  {76.2678,6.67006 },
  {76.3916,6.7678  },
  {76.557,6.8916   },
  {76.7656,7.0154  },
  {76.9326,7.11312 },
  {77.1389,7.27603 },
  {77.4305,7.45846 },
  {77.7621,7.69304 },
  {78.1786,7.95366 },
  {78.5102,8.18823 },
  {78.9672,8.49447 },
  {79.5487,8.88541 },
  {80.5876,9.57608 },
  {81.377,10.1039  },
  {82.6222,10.9574 }
};

  double gamma = photon_energy*Eh_to_eV;
  short int i=0;
  //find the energy above gamma
  for(i=0; ( float(gamma) > lt_Xe_photo2e[i][0]) && (i < Nb_entries_Xe_2e_photo_ionization);i++);

  //If it is really close to the threshold just use the 1st value
  if (i==0) return lt_Xe_photo2e[0][1]*Mb_to_atomic_area;
  if (i==Nb_entries_Xe_2e_photo_ionization){
   std_cout << "Photon too energetic, ran out of experimental data in xsection_Xe_2e (SinglePhoton.cpp)\n";
   abort();
  }

  const short int index_above = (short int) i;
  const short int index_below = (short int) i-1;
  //linearly interpolate between the above and below points
  const float dx = (float) lt_Xe_photo2e[index_above][0] - lt_Xe_photo2e[index_below][0];
  const float dy = (float) lt_Xe_photo2e[index_above][1] - lt_Xe_photo2e[index_below][1];
  const double slope = (double) dy/dx;
  const double intercept = (double) lt_Xe_photo2e[index_above][1] - slope*lt_Xe_photo2e[index_above][0];


  //return in bohr squared. Mb * (0.01 cm/m)^2 / ( a0 m/bohr)^2
  return (double) (slope*gamma+intercept)*Mb_to_atomic_area;

}


double Ionization_Rate_SinglePhoton_2e(const double Ip_au,
                                    const double Ephoton_au,
                                    const int ion_charge,
                                    const elem_props &element,
                                    const double omega_l,
                                    const double num_photons,
                                    const double I_0_const,
                                    const double time
)
{

    // Original version using the Formula from Amusia for the
    // ground state of hydrogen and small photoelectron energy
    //double wspi = 0.0;


    const double sin_omega_t = sin(omega_l*time);

    //The interpolation is done is abolute photon energy in eV
    //With muffin tin the Ip is lowered. This is used here as a
    // more energetic photon. Thus we add the Ip_correction of the
    //muffin tin (0 in the case of no muffin tin).
    const double photon_energy_au =  Ephoton_au+ (element.IpsLowest[0]*eV_to_Eh- Ip_au );
    const double atom_xsection = xsection_Xe_2e( photon_energy_au,element);

//   std_cout << "Ephoton_au="<<Ephoton_au<<" ele.Ip="<<element.IpsLowest[ion_charge]*eV_to_Eh<<" Ip_au="<<Ip_au<<" Xsec="<<atom_xsection<<"\n";
//       return atom_xsection ;
    return num_photons * I_0_const *atom_xsection* sin_omega_t * sin_omega_t * sin_omega_t * sin_omega_t*a0*a0;
}


//----------------------------------Auger data ------------------------------------



/**
 * A function to return the cross-section (in Bohr^2)
 * of Auger decay ionization data taken from experimental data
 * or regular outer ionization
 * @param photon_energy The energy of the photon in Hartree
 * @param element The element under examination. It only works
 *                for Xe but if the input file changes the Ips
 *                the threshold here will automatically change,
 *                by passing the element's properties.
 * @return The cross section in atomic units (Bohr^2)
 */
double xsection_table_of_data(double photon_energy,const double Ip_au,const float data[][2], const int Nb_entries){

  //Test if the photon is energetic enogh to do single photon double ionization
  if (photon_energy < Ip_au ) return 0.0;

  double gamma = photon_energy*Eh_to_eV;
  short int i=0;
  //find the energy above gamma
  for(i=0; ( float(gamma) > data[i][0]) && (i < Nb_entries);i++);

  //If it is really close to the threshold just use the 1st value
  if (i==0) return data[0][1]*Mb_to_atomic_area;
  if (i==Nb_entries){
   std_cout << "Photon too energetic, ran out of experimental data in data (SinglePhoton.cpp)\n";
   abort();
  }

  const short int index_above = (short int) i;
  const short int index_below = (short int) i-1;
  //linearly interpolate between the above and below points
  const float dx = (float) data[index_above][0] - data[index_below][0];
  const float dy = (float) data[index_above][1] - data[index_below][1];
  const double slope = (double) dy/dx;
  const double intercept = (double) data[index_above][1] - slope*data[index_above][0];

  //return in bohr squared. Mb * (0.01 cm/m)^2 / ( a0 m/bohr)^2
  return (double) (slope*gamma+intercept)*Mb_to_atomic_area;
}


/**
 * A function to obtain the photoionization of Ar from the small data list
 * Ar_xsec (done quickly by adding all the hyperfine levels at the same energy
 * using http://aphysics2.lanl.gov/). linearly interpolates between data points
 *
 * @param ion_cs Charge of the ion
 * @param photonE_au The photon energy in Hartree
 * @return  The cross-section in meters squared
 */
double Argon_photoXsection(int ion_cs, double photonE_au){
  if (ion_cs > 1) return 0.0; //values not implimented

  //the table is in constant delta E (in eV) so subract two subsequent values
  //to get the deltaE
  const double deltaE_eV = Ar_xsec[ion_cs][1][0] -Ar_xsec[ion_cs][0][0];
  const double startE_eV = Ar_xsec[ion_cs][0][0];
  const double endE_eV   = Ar_xsec[ion_cs][19][0];
  const double photoE_eV = photonE_au*Eh_to_eV;

  if ((ion_cs ==1 )&&((photoE_eV < startE_eV) || (photoE_eV > endE_eV))){
    std::cout << "Photon out of bounds with energy: " << photoE_eV << " eV" << std::endl;
    return 0.0;
  }

  int lower_index = 0;

  if (ion_cs == 0){
    int i=0;
    while ((Ar_xsec[0][i++][0] < photoE_eV) && (i<45));
    lower_index = i-1;
    if (i == 45) {std::cout << "Argon_photoXsection failed" << std::endl; abort();}
  } else{
    lower_index = floor((photoE_eV -startE_eV)/deltaE_eV );
  }
  const int upper_index = lower_index +1;

  //linearly interpolate between the above and below points
  const float dx =  Ar_xsec[ion_cs][upper_index][0] - Ar_xsec[ion_cs][lower_index][0];
  const float dy =  Ar_xsec[ion_cs][upper_index][1] - Ar_xsec[ion_cs][lower_index][1];
  const double slope =  dy/dx;
  const double intercept = Ar_xsec[ion_cs][upper_index][1] - slope*Ar_xsec[ion_cs][upper_index][0];
  const double xsec_si = (slope*photoE_eV+intercept)*Mb_to_m2;

  return xsec_si; //return the cross-section in m^2
}

  //A function to do all the necessary things for the photoionization of Xe in the region of the 4d resonance
  //It creates the electrons and increments the charges etc
void photoionization_Xe_4d(void *ion,void *al,void *el,
                                   int Nb_atoms, int Nb_atoms_max,int Nb_electrons_max,int oe_size,
                                   bool &remove_energy_from_orbital_e,
                                   const double time, const double dt, const double tskip, double Ip_au_correction, double gamma, double K_OrbitingE,
                                   int **ions_w_classical_electrons,double laser_field[3],
                                   const double sin_omega_t,double I_0_const,double omega_laser,double cluster_area,
                                   unsigned long int &index_next_empty_space, int &Nb_electrons,bool &did_ionization_occur,const elem_props &element,
                                   double &number_photons, double &delta_energy, laser_props &laser,int *ionizedlist, Lib_PRNG &prng,FILE *fh_out ){
  //use to access Ips
  const short int l_of_d_states = 2; //the angular quantum number's integer value for 4d
  const short int n_value_for_4d = 4;//the principle quantum number's integer value for 4d

  //obtain useful parameters for the calculations
  const int ion_id = Get_Id(ion);
  const short int ion_aes = Get_Excited_Auger_State(ion_id);
  const int ion_cs = Get_Charge_State(ion);

  double Ip = element.IpsLowest[ion_cs]*eV_to_J;
  double Ip_4d_au = element.Ips[get_element_index(l_of_d_states, n_value_for_4d, ion_cs, element.max_l, element.max_n)]*eV_to_Eh;

  double wspi = 0.0;
  double xsec[4] = {0.0,0.0,0.0,0.0};
  const double rate_factor = number_photons * I_0_const *  sin_omega_t * sin_omega_t * sin_omega_t * sin_omega_t;
  int ionization_process = IONIZATION_PROCESS_SINGLE;

  if (ion_cs == 0 ){
    //outer shell ionization
    //we multiply by 1.797 as this: doi:10.1038/nature05648 states that 13% of the total cross-section is from 5s+5p so this scales that so it is correct
    //THis is incorrect for the 93eV so it was removed as the nature paper was at 90 eV
    xsec[0] = xsection_table_of_data(gamma*J_to_Eh,Ip*J_to_Eh,lt_Xe_5p6_photo,Nb_entries_Xe_5p6_photo_ionization)*atomic_area_to_Mb; //Mb
    //inner shell (4d) ionization single Auger
    xsec[1] = xsection_table_of_data(gamma*J_to_Eh,Ip_4d_au,lt_Xe_Auger_photo_1e,Nb_entries_Xe_Auger_1e_photo_ionization)*atomic_area_to_Mb; //Mb
    //inner shell (4d) ionization double Auger
    xsec[2] = xsection_table_of_data(gamma*J_to_Eh,Ip_4d_au,lt_Xe_Auger_photo_2e,Nb_entries_Xe_Auger_2e_photo_ionization)*atomic_area_to_Mb; //Mb
/*//std::cout << "xsec[0] " << xsec[0] << " xsec[1] " << xsec[1] << " xsec[2] " << xsec[2] << std::endl;
std::cout << "gamma " << gamma*J_to_Eh << " Ip*J_to_Eh " << Ip*J_to_Eh << " Nb_entries_Xe_5p6_photo_ionization=" <<Nb_entries_Xe_5p6_photo_ionization<<std::endl;*/
    //add all the cross-sections and save the total
    for(int i = 0;i<3;i++) xsec[3] += xsec[i];

    //convert xsection to rate
    wspi = rate_factor* xsec[3];

    double delta_qq = 1.0 - exp(-wspi*dt);
    double rand_nmb = prng.Get_Random();
//std::cout << "xsec[0] " << xsec[0] << " xsec[1] " << xsec[1] << " xsec[2] " << xsec[2] << " xsec[3]" << xsec[3] <<std::endl;
    // Monte-Carlo test for ionization
    if (rand_nmb <= delta_qq){
      //An ionization will take place. Now to decide which one.
      rand_nmb = prng.Get_Random();

      //PICK AN OPTION: weigh the options by their cross-section
/*std::cout << "xsec[1]=" << xsec[1] << "  xsec[2]=" << xsec[2]
          << "  xsec[3]=" << xsec[3]
          << "  xsec[1]/xsec[3]=" << xsec[1]/xsec[3]
          << "  rnd="<<  rand_nmb << std::endl;*/
      if (xsec[1]/xsec[3] >= rand_nmb){
       //-------------------- Xe^1+ --> Xe^2+ -------------------------------------
        //      do inner shell ionization
       Ip = Ip_4d_au * Eh_to_J; //assumes 4d_5/2
       //pick the excited state it is in
       //chose the subshell (it came from d5/2 or d3/2)

       rand_nmb = prng.Get_Random();
       if (rand_nmb < single_Auger_d52_branching_ratio){
         //photoelectron came from the d_5/2 shell
         Set_Excited_Auger_Time(ion_id, time, Single_Auger_Excited_d52);
         //set the code for the ionization process and
         //multiply by 10 to know it was only the d-part so far
         ionization_process = Single_Auger_Excited_d52*10.0;
       } else {
         //photoelectron came from the d_3/2 shell
         Ip += Ip_difference_to_d32_from_d52*eV_to_J;
         Set_Excited_Auger_Time(ion_id, time, Single_Auger_Excited_d32);
         ionization_process = Single_Auger_Excited_d32*10.0;
       }
     } else if ((xsec[1]+xsec[2])/xsec[3] >= rand_nmb) {
         //-------------------- Xe^1+ --> Xe^3+ -------------------------------------
         //choose the subshell (it came from d5/2 or d3/2)
         rand_nmb = prng.Get_Random();
         if (rand_nmb < double_Auger_d52_branching_ratio){
           //photoelectron came from the d_5/2 shell
           Set_Excited_Auger_Time(ion_id, time, Double_Auger_Excited_d52);
           ionization_process = Double_Auger_Excited_d52*10.0;
         } else {
           //photoelectron came from the d_3/2 shell
           Ip += Ip_difference_to_d32_from_d52*eV_to_J;
           Set_Excited_Auger_Time(ion_id, time, Double_Auger_Excited_d32);
           ionization_process = Double_Auger_Excited_d32*10.0;
         }
      } //else {
       //already setup to outer ionization by default so nothing to do
      //}//end Double auger tree

      //For now only eject the d-shell electron from the correct shell (d_5/2 or d_3/2)
      //Only the IP has changed from this function calls perspective compared with outershell ionization
      do_a_single_photon_ionization(ion,al,el,
                                      ion_id, ion_cs, time,
                                      Nb_atoms,Nb_atoms_max,Nb_electrons_max,oe_size,
                                      remove_energy_from_orbital_e,
                                      Ip_au_correction, gamma,Ip, K_OrbitingE,
                                      ions_w_classical_electrons, laser_field,
                                      index_next_empty_space, Nb_electrons,element,
                                      number_photons, delta_energy, laser,prng,ionization_process ,fh_out );
      ionizedlist[0]++;
      ionizedlist[Get_Id(ion) + 1] = Get_Id(ion);
      did_ionization_occur = true;
    } //end if (rand_nmb <= delta_qq)

  } //end if ion_cs==0

//*************debug
//  else if (ion_cs > 0) return;
//*****debug
  else if (ion_cs == 1 &&  ion_aes >= Single_Auger_Excited_d52  ){ //for 4d-1 state neutral states
    //outer shell ionization
    xsec[0] = Ionization_Rate_SinglePhoton(Ip*J_to_Eh,laser.pho_engy_au,ion_cs,
                       element,omega_laser,number_photons,I_0_const,time+tskip)/(cluster_area*rate_factor);
    //ensure this is not an already doubly excited state
    char digits[5];
    sprintf(digits,"%d",ion_cs);

    if (digits[1] ==0 ){
      //inner shell (4d) ionization any Auger
      xsec[1] = xsection_table_of_data(gamma*J_to_Eh,Ip_4d_au,lt_Xep_Auger_photo_4d9_5p6_D,Nb_entries_Xe_4d9_5p6_D_photo_ionization)*atomic_area_to_Mb; //Mb
      //not data to be more precise
      xsec[2] = xsec[1]; //Mb

      //branch the cross-section by the ratio of d_5/2 to d_3/2 so we can determine where
      //the d-electron will come from with one random number
      xsec[1] *= Xe_4d8_5p6_4d52_branching_ratio;
      xsec[2] *= Xe_4d8_5p6_4d32_branching_ratio;
    }//end if the stae is NOT already doubly excited

    //add all the cross-sections and save the total
    for(int i = 0;i<3;i++) xsec[3] += xsec[i];

    //convert xsection to rate
    wspi = rate_factor * xsec[3];

    double delta_qq = 1.0 - exp(-wspi*dt);
    double rand_nmb = prng.Get_Random();

    // Monte-Carlo test for ionization
    if (rand_nmb <= delta_qq){
      //An ionization will take place. Now to decide which one.
      rand_nmb = prng.Get_Random();
//std::cout << "xsec[0] " << xsec[0] << " xsec[1] " << xsec[1] << " xsec[2] " << xsec[2] << std::endl;
      //PICK AN OPTION: weigh the options by their cross-section
      if (xsec[1]/xsec[3] >= rand_nmb){
        //      do inner shell ionization from d_5/2
        Ip = Ip_4d9_5p6_to_4d8_5p6*eV_to_J;  //assumes 4d_5/2

        //photoelectron came from the d_5/2 shell
        //Set_Excited_Auger_Time(ion_id,-1, ion_aes+excited_4d8_from_d52);//-1 to only change the state not the time
        //Create an entry in the has table for this doubly excited Auger process
        Set_Excited_Auger_Time(ion_id, time, ion_aes+excited_4d8_from_d52);
        ionization_process = ion_aes+excited_4d8_from_d52;
      } else if ((xsec[2]+xsec[1])/xsec[3] >= rand_nmb){
        //      do inner shell ionization from d_3/2
        Ip = Ip_4d9_5p6_to_4d8_5p6+ Ip_difference_4d9_5p6_to_4d8_5p6_d32_d52;  //assumes 4d_5/2
        Ip *= eV_to_J;
        //photoelectron came from the d_3/2 shell
        Set_Excited_Auger_Time(ion_id, time, ion_aes+excited_4d8_from_d32);
        ionization_process = ion_aes+excited_4d8_from_d32;
      } //else {
        //do outershell ionization
        //nothing to be done as Ip is set by default to outer shell
      //}//end Auger tree


       //For now only eject the d-shell electron from the correct shell (d_5/2 or d_3/2)
       //Only the IP has changed from this function calls perspective compared with outershell ionization
       do_a_single_photon_ionization(ion,al,el,
                                      ion_id, ion_cs, time,
                                      Nb_atoms,Nb_atoms_max,Nb_electrons_max,oe_size,
                                      remove_energy_from_orbital_e,
                                      Ip_au_correction, gamma,Ip, K_OrbitingE,
                                      ions_w_classical_electrons, laser_field,
                                      index_next_empty_space, Nb_electrons,element,
                                      number_photons, delta_energy, laser,prng, ionization_process,fh_out );
        ionizedlist[0]++;
        ionizedlist[Get_Id(ion) + 1] = Get_Id(ion);
        did_ionization_occur = true;
      }//end if (rand_nmb <= delta_qq)
  }//end else if ion_cs==1 && it is a 4d-1 hole
  else if (ion_cs == 1 || ion_cs == 2){
    if (ion_cs == 1) {
      //outer shell ionization
      xsec[0] = xsection_table_of_data(gamma*J_to_Eh,Ip*J_to_Eh,lt_Xep_5p5_photo,Nb_entries_Xep_5p5_photo_ionization)*atomic_area_to_Mb; //Mb
      //inner shell (4d) ionization single Auger
      xsec[1] = xsection_table_of_data(gamma*J_to_Eh,Ip_4d_au,lt_Xep_Auger_photo_1e,Nb_entries_Xep_Auger_1e_photo_ionization)*atomic_area_to_Mb; //Mb
    } else { //Xe^2+
      //outer shell ionization
      xsec[0] = xsection_table_of_data(gamma*J_to_Eh,Ip*J_to_Eh,lt_Xe2p_5p4_photo,Nb_entries_Xe2p_5p4_photo_ionization)*atomic_area_to_Mb; //Mb
        //inner shell (4d) ionization single Auger if not already excited
      if (ion_aes < Single_Auger_Excited_d52)
        xsec[1] = xsection_table_of_data(gamma*J_to_Eh,Ip_4d_au,lt_Xe2p_Auger_photo_1e,Nb_entries_Xe2p_Auger_1e_photo_ionization)*atomic_area_to_Mb; //Mb
    }

    //inner shell (4d) ionization double Auger
    xsec[2] = 0.0; //there is no double Auger decay

    //Do not allow undecayed (Auger-excited) Xe^2+ to ionize the 4d (would require >98eV photons)
    if (ion_cs == 2 && ion_aes >= Single_Auger_Excited_d52)//Single_Auger_Excited_d52 is the lowest number for Auger-excitation
      xsec[1] = 0.0;//4d9 5p5 cannot now do 4d8 5p5 only 4d9 5p4

    //add all the cross-sections and save the total
    for(int i = 0;i<3;i++) xsec[3] += xsec[i];

    //convert xsection to rate
    wspi = rate_factor * xsec[3];

    double delta_qq = 1.0 - exp(-wspi*dt);
    double rand_nmb = prng.Get_Random();

    // Monte-Carlo test for ionization
    if (rand_nmb <= delta_qq){
      //An ionization will take place. Now to decide which one.
      rand_nmb = prng.Get_Random();
//std::cout << "xsec[0] " << xsec[0] << " xsec[1] " << xsec[1] << " xsec[2] " << xsec[2] << std::endl;
      //PICK AN OPTION: weigh the options by their cross-section
      if (xsec[1]/xsec[3] >= rand_nmb){
      //      do inner shell ionization from 4d10 -> 4d9
      //-------------------- Xe^q+ --> Xe^(q+1)+* -------------------------------------
         Ip = Ip_4d_au * Eh_to_J; //assumes 4d_5/2
         //pick the excited state it is in
         rand_nmb = prng.Get_Random();

         if (rand_nmb < Xep_Auger_d52_branching_ratio){
           //photoelectron came from the d_5/2 shell
           Set_Excited_Auger_Time(ion_id, time, Single_Auger_Excited_d52);
           ionization_process = Single_Auger_Excited_d52*10.0;
         } else {
           //photoelectron came from the d_3/2 shell
           Ip += -Ip_difference_to_d32_from_d52*eV_to_J;
           Set_Excited_Auger_Time(ion_id, time, Single_Auger_Excited_d32);
           ionization_process = Single_Auger_Excited_d32*10.0;
         }
      } //else {
        //do outershell ionization
        //Nothing to be done, Ip is already set (for explaination only)
      //} //end Double Auger tree

       //For now only eject the d-shell electron from the correct shell (d_5/2 or d_3/2)
       //Only the IP has changed from this function calls perspective compared with outershell ionization
       do_a_single_photon_ionization(ion,al,el,
                                      ion_id, ion_cs, time,
                                      Nb_atoms,Nb_atoms_max,Nb_electrons_max,oe_size,
                                      remove_energy_from_orbital_e,
                                      Ip_au_correction, gamma,Ip, K_OrbitingE,
                                      ions_w_classical_electrons, laser_field,
                                      index_next_empty_space, Nb_electrons,element,
                                      number_photons, delta_energy, laser,prng, ionization_process,fh_out );
        ionizedlist[0]++;
        ionizedlist[Get_Id(ion) + 1] = Get_Id(ion);
        did_ionization_occur = true;
    }//end random test
  }//end ion_cs ==1||2 and not excited
  else if (ion_cs > 2 && ion_cs < 7){

    if (ion_cs == 3)
      xsec[0] = xsection_table_of_data(gamma*J_to_Eh,Ip*eV_to_Eh,lt_Xe3p_5p3_photo,Nb_entries_Xe3p_5p3_photo_ionization)*atomic_area_to_Mb; //Mb
    else if (ion_cs == 4)
      xsec[0] = xsection_table_of_data(gamma*J_to_Eh,Ip*eV_to_Eh,lt_Xe4p_5p2_photo,Nb_entries_Xe4p_5p2_photo_ionization)*atomic_area_to_Mb; //Mb
    else if (ion_cs == 5)
      xsec[0] = xsection_table_of_data(gamma*J_to_Eh,Ip*eV_to_Eh,lt_Xe5p_5p1_photo,Nb_entries_Xe5p_5p1_photo_ionization)*atomic_area_to_Mb; //Mb
    else
      xsec[0] = xsection_table_of_data(gamma*J_to_Eh,Ip*eV_to_Eh,lt_Xe6p_5s2_photo,Nb_entries_Xe6p_5s2_photo_ionization)*atomic_area_to_Mb; //Mb


    //do standard single photon ionization from p and s shell
        //outer shell ionization


    //convert xsection to rate
    wspi = rate_factor * xsec[0];

    double delta_qq = 1.0 - exp(-wspi*dt);
    double rand_nmb = prng.Get_Random();

    // Monte-Carlo test for ionization
    if (rand_nmb <= delta_qq){
//std::cout << "xsec[0] " << xsec[0] << " xsec[1] " << xsec[1] << " xsec[2] " << xsec[2] << std::endl;
       //For now only eject the d-shell electron from the correct shell (d_5/2 or d_3/2)
       //Only the IP has changed from this function calls perspective compared with outershell ionization
       do_a_single_photon_ionization(ion,al,el,
                                      ion_id, ion_cs, time,
                                      Nb_atoms,Nb_atoms_max,Nb_electrons_max,oe_size,
                                      remove_energy_from_orbital_e,
                                      Ip_au_correction, gamma,Ip, K_OrbitingE,
                                      ions_w_classical_electrons, laser_field,
                                      index_next_empty_space, Nb_electrons,element,
                                      number_photons, delta_energy, laser,prng, IONIZATION_PROCESS_SINGLE,fh_out );
        ionizedlist[0]++;
        ionizedlist[Get_Id(ion) + 1] = Get_Id(ion);
        did_ionization_occur = true;
      }//end if (rand_nmb <= delta_qq)


  }
   //multiphoton ionization (7+ to 15+)
   else if (ion_cs < 16){
    //cross-section's are taken from PRL 102 033002 (NOT EXPERIMENTAL) @ 13.3nm
    //1st element is 2-photon ionization of a 7+
    const double multiphoton_xsec[9] = {
               7e-49,7e-49, //2-photon [cm^4*sec ]
               2e-79,2e-79,2e-79, //3-photon [cm^6*sec^2 ]
               3e-114,1e-114,1e-112,4e-112 //4-photon [cm^8*sec^3 ]
    };
    xsec[0] = multiphoton_xsec[ion_cs - 7];
    //convert xsection to rate, sigma*I^2
    //I is in W/cm^2 and multiphoton_xsec is in cm
    double rate_factor = laser.intensity*laser.intensity
                       /(laser.ww*hbar)/(laser.ww*hbar);
    short int number_of_gammas = 2; //the number of photons absorbed
    if (ion_cs < 12) { //3-photon
      rate_factor *=laser.intensity/(laser.ww*hbar);
      number_of_gammas = 3;
    } else if (ion_cs < 16){
      rate_factor *=laser.intensity*laser.intensity
                   /(laser.ww*hbar)/(laser.ww*hbar);
      number_of_gammas = 4;
    }

    wspi = rate_factor* xsec[0];
    double delta_qq = 1.0 - exp(-wspi*dt);
    double rand_nmb = prng.Get_Random();
    // Monte-Carlo test for ionization
    if (rand_nmb <= delta_qq){
//std::cout << "xsec[0] " << xsec[0] << " xsec[1] " << xsec[1] << " xsec[2] " << xsec[2] << std::endl;
       //For now only eject the d-shell electron from the correct shell (d_5/2 or d_3/2)
       //Only the IP has changed from this function calls perspective compared with outershell ionization
       do_a_single_photon_ionization(ion,al,el,
                                      ion_id, ion_cs, time,
                                      Nb_atoms,Nb_atoms_max,Nb_electrons_max,oe_size,
                                      remove_energy_from_orbital_e,
                                      Ip_au_correction,number_of_gammas* gamma,Ip, K_OrbitingE,
                                      ions_w_classical_electrons, laser_field,
                                      index_next_empty_space, Nb_electrons,element,
                                      number_photons, delta_energy, laser,prng,
                                      IONIZATION_PROCESS_MULTI_PHOTON,fh_out );
        ionizedlist[0]++;
        ionizedlist[Get_Id(ion) + 1] = Get_Id(ion);
        did_ionization_occur = true;
        //the do_a_single_photon_ionization routine takes one photon away
        //the following removes the rest
        if (ion_cs < 9){ //2-photon
          number_photons   -= 1.0;
          laser.nb_photons -= 1.0;
        } else if (ion_cs < 12) { //3-photon
          number_photons   -= 2.0;
          laser.nb_photons -= 2.0;
        } else if (ion_cs < 16){
          number_photons   -= 3.0;
          laser.nb_photons -= 3.0;
        }

      }//end if (rand_nmb <= delta_qq)

  }//end multiphoton

}//end void photoionization_Xe_4d

void do_a_single_photon_ionization(void *ion,void *al,void *el,
                                   int ion_id, int ion_cs, const double time,
                                   int Nb_atoms, int Nb_atoms_max,int Nb_electrons_max,int oe_size,
                                   bool &remove_energy_from_orbital_e,
                                   double Ip_au_correction, double gamma, double Ip, double K_OrbitingE,
                                   int **ions_w_classical_electrons,double laser_field[3],
                                   unsigned long int &index_next_empty_space, int &Nb_electrons,const elem_props &element,
                                   double &number_photons, double &delta_energy,
                                   laser_props &laser, Lib_PRNG &prng,
                                   const int ionization_process,FILE *fh_out )
{
    void *nce = NULL;
    const double Eabs = Vector_Length(laser_field); // |E|   [V . m^-1]

    std_cout << "single photon ionization occured ("<<ion_cs<<"+ --> "<<ion_cs+1<<"+)  Id = "<<Get_Id(ion)<<"  process="<<ionization_process<<"\n";

    if (Ip_au_correction !=0.0) std_cout << "SP.Ip_correction_au=" << Ip_au_correction << "\n";
    // The ion-electron system has an intrisinct energy: the Ip.
    // This energy "disappear" in the code. We also have a net gain
    // of the energy of the photon.
    // We return this value so the code can keep track of it.
    delta_energy += gamma - Ip;
    //std_cout << "delta_energy = " << delta_energy*J_to_eV << " eV\n";

    number_photons   -= 1.0;
    laser.nb_photons -= 1.0;
    nce = get_voidp(el, index_next_empty_space);

    Create_Electron(
        el, ion,
        time,
        Nb_atoms, Nb_atoms_max,
        Nb_electrons, Nb_electrons_max,
        index_next_empty_space,
        element,
        "Called from Ionization_SinglePhoton() in library"
    );

    //set the position
    for (int d = 0 ; d < 3 ; d++) Get_Position(nce)[d] = Get_Position(ion)[d]+electron_creation_distance* (laser_field[d]/Eabs);

    // Potential energy between the new electron and its parent ion (with updated charge)
    potential_paramaters potparams;
    Potentials_Set_Parameters(nce, ion, element, potparams);
    const double U1f     = (-e0) * Calculate_Potential(nce, ion, element, potparams);
    const double nce_K   = gamma - Ip - U1f;
    const double nce_vel = sqrt(2.0 * nce_K / me);

    // Choose randomly the direction of the new electron's velocity
    double E_unit[3];
    double Eabs_rand = Eabs;
    const double rv = prng.Get_Random();
    if ( (rv > 0.5) != 1 ) Eabs_rand = -Eabs_rand;
    //std_cout << "0. (laser.nb_call_to_rand,Lib_Random_Number_Get()) = ("<<laser.nb_call_to_rand<<","<<rv<<")\n";
    for (int d = 0 ; d < 3 ; d++) E_unit[d] = laser_field[d] / Eabs_rand;
    for (int d = 0 ; d < 3 ; d++) Get_Velocity(nce)[d] = nce_vel * E_unit[d];

    // ******************************************************
    // Since each classically orbiting electrons have shielded
    // the ion and lowered the Ip via Ip_correction, they need
    // to pay to balance the energy.
    if ((oe_size > 0) && (ions_w_classical_electrons[ion_id] != NULL)
         && remove_energy_from_orbital_e
       )
    {
        Remove_IpCorrection_From_Orbiting_Electrons(al, ions_w_classical_electrons[ion_id],
                                                     Eh_to_J*Ip_au_correction, K_OrbitingE, -1);
    }



    // The ion cannot be ionized for dt=hbar/dE
    // where dE is the transition energy (photon energy)
    int next_ion = time + next_ion_wait;
    if( next_ion > Get_NextIon(ion) ) Set_NextIon(ion, next_ion);

  // Save to passed file handle
    if(Lib_Get_Rank() == 0)
    {
      if (fh_out != NULL)
      {
          fprintf(fh_out, "%.15g, %2d, %2d, %7d, %7d, %7d, %10.8g, %10.8g, %4d, %4d\n",
                           time*s_to_fs,
                                    ionization_process,
                                        Get_Charge_State(ion),
                                             Get_Id(ion),
                                                 Get_Id(nce),
                                                     -1,
                                                         nce_K*J_to_Eh,
                                                                Ip_au_correction,
                                                                       Get_Excited_State_index(ion),
                                                                            -1);
          // Get_Excited_State_index(ion) is saved to have simimlar output as Impact.cpp
          fflush(fh_out);
      }
    }

     /* Debug output
     std_cout << "Id="<<Get_Id(ion)<<"  CS="<<Get_Charge_State(ion)<<"  Pot="<<U1f*J_to_Eh<<"  KE="<<Vector_Length_Squared(Get_Velocity(nce))*me*0.5*J_to_Eh<<" Ip="<<Ip_au<<" KE_theory="<<nce_K*J_to_Eh<<" Get_pot="<<Calculate_Potential(nce, ion, element, potparams)*eV_to_Eh<<"\n";
     std_cout << "potparams.r="<<potparams.r/a0<<"\n";
     std_cout << "Pos=("<<Get_Position(nce)[0]<<","<<Get_Position(nce)[1]<<","<<Get_Position(nce)[2]<<") "<<sqrt(Vector_Length_Squared(Get_Position(nce)))/a0<<"  Ion_Pos=("<<Get_Position(ion)[0]<<","<<Get_Position(ion)[1]<<","<<Get_Position(ion)[2]<<")\n";*/
}

/*************** End of file *****************************************/



















































/****************************************************************

    Routines for reading XML input files

****************************************************************/

#include <iostream>
#include <stdint.h> // (u)int64_t
#include <vector>

#include "Constants.hpp"
#include "ReadXML.hpp"
#include "General.hpp"
#include "tinyxml/tinyxml.hpp"
#include "Std_Cout.hpp"

using namespace std;

// **************************************************************
// ********** Local functions prototypes ************************
// **************************************************************

void   XML_Get_Characters(TiXmlNode *root, const char *elements, char *buff);
bool   XML_Get_Bool(      TiXmlNode *root, const char *elements);
int    XML_Get_Int(       TiXmlNode *root, const char *elements);
long int XML_Get_LInt(    TiXmlNode *root, const char *elements);
uint64_t XML_Get_UInt64(  TiXmlNode *root, const char *elements);
int64_t  XML_Get_Int64(   TiXmlNode *root, const char *elements);
double XML_Get_Double(    TiXmlNode *root, const char *elements);

void   XML_Get_Attribute_Char(  TiXmlNode *root, const char *attribute, char *read_attribute);
int    XML_Get_Attribute_Int(   TiXmlNode *root, const char *attribute);
double XML_Get_Attribute_Double(TiXmlNode *root, const char *attribute);

void XML_SplitString(const std::string &to_split,
                     const char delimiter,
                     std::vector<std::string> &split_strings);
void XML_Get_SubNode(TiXmlNode *root, const char *elements, TiXmlNode **subnode);
int XML_Get_SubNode_Matching_Attribute(TiXmlNode *root,
                                         const char *elements,
                                         const char *attribute,
                                         const int attribute_value,
                                         TiXmlNode **subnode);
int XML_Get_SubNode_Matching_Attribute(TiXmlNode *root,
                                         const char *elements,
                                         const char *attribute1,
                                         const int attribute1_value,
                                         const char *attribute2,
                                         const int attribute2_value,
                                         TiXmlNode **subnode);
int XML_Get_SubNode_Matching_Attribute(TiXmlNode *root,
                                         const char *elements,
                                         const char *attribute,
                                         const char *attribute_value,
                                         TiXmlNode **subnode);

int XML_Count_Elements(TiXmlNode *root, const char *element);

void XML_Get_max_n(TiXmlNode *Z, elem_props &element);
void XML_Get_max_l(TiXmlNode *Z, elem_props &element);
void Allocate_Element_Arrays(elem_props &element);
void XML_Read_Occupied_and_Ips_and_Lotz(TiXmlNode *IPs, elem_props &element);
void Print_Test_Information(TiXmlNode *RootNode, elem_props &element);
void Print_Ips_and_Occupations(elem_props &element);

// **************************************************************
// ********** Accessible functions implementations **************
// **************************************************************
void Read_XML_AtomicProperties(elem_props &element,
                                const char filename[])
{
    if ( strlen(filename) > 1000 )
    {
        DEBUGP("XML input file filename too long!!!\n");
        std_cout << "Printing the filename might crash. Print it regardless:\n";
        std_cout << filename << "\n";
        abort();
    }

    // Open XML file
    TiXmlDocument input(filename);
    TiXmlHandle inputHandle(&input);

    // Load it in memory and check
    bool loadOkay = input.LoadFile();
    if (!loadOkay)
    {
        cout << "ERROR: Cannot open/read file " << filename
            << ".\nExiting." << endl;
        abort();
    }

    TiXmlNode *RootNode = input.FirstChild("AtomicProperties");

    TiXmlNode *IPs, *FirstZ, *ip_state;
    const int charge_state = 0;
    const char orbital[] = "3d";
    int return_value;
    XML_Get_SubNode(RootNode, "ionizationPotentials", &IPs);
    return_value = XML_Get_SubNode_Matching_Attribute(IPs, "z", "z", charge_state, &FirstZ);
    if (return_value != TIXML_SUCCESS)
    {
        DEBUGP("Node 'z' does not seems to exist!");
        abort();
    }
    return_value = XML_Get_SubNode_Matching_Attribute(FirstZ, "ip", "name", orbital, &ip_state);
    if (return_value != TIXML_SUCCESS)
    {
        DEBUGP("Node 'ip' does not seems to exist!");
        abort();
    }

    XML_Get_Characters(RootNode, "name", element.name);
    XML_Get_Characters(RootNode, "symbol", element.symbol);

    element.atomicNumber = XML_Get_Int(RootNode, "atomicNumber");
    element.mass         = XML_Get_Double(RootNode, "mass");
    element.next_nghb    = XML_Get_Double(RootNode, "condensed/closestNeighbour");
    element.next_nghb_05 = 0.5 * element.next_nghb;

    // Because charge states start at 0, count will return one more
    // then the maximum charge state, so remove 1.
    element.max_Z        = XML_Count_Elements(IPs, "z") - 1;
    element.nb_avail_ips = XML_Count_Elements(FirstZ, "ip");

    XML_Get_max_l(FirstZ, element);
    XML_Get_max_n(FirstZ, element);

    Allocate_Element_Arrays(element);

    XML_Read_Occupied_and_Ips_and_Lotz(IPs, element);

    // Usefull for testing
//     Print_Test_Information(RootNode, element);
}

// **************************************************************
void Print_Test_Information(TiXmlNode *RootNode, elem_props &element)
{
    TiXmlNode *IPs, *SomeZ, *ip_state;

    const int charge_state = 5;
    const char orbital[] = "5p";

    int return_value;
    XML_Get_SubNode(RootNode, "ionizationPotentials", &IPs);
    return_value = XML_Get_SubNode_Matching_Attribute(IPs, "z", "z", charge_state, &SomeZ);
    if (return_value != TIXML_SUCCESS)
    {
        DEBUGP("Node 'z' does not seems to exist!");
        abort();
    }
    return_value = XML_Get_SubNode_Matching_Attribute(SomeZ, "ip", "name", orbital, &ip_state);
    if (return_value != TIXML_SUCCESS)
    {
        DEBUGP("Node 'ip' does not seems to exist!");
        abort();
    }

    char ip_units[100];
    XML_Get_Attribute_Char(IPs, "units", ip_units);

    cout << "##############################" << endl
         << "charge state   : " << charge_state << endl
         << "orbital        : " << orbital << endl
         << "n              : " << XML_Get_Attribute_Int(ip_state, "n") << endl
         << "l              : " << XML_Get_Attribute_Int(ip_state, "l") << endl
         << "occupied       : " << XML_Get_Attribute_Int(ip_state, "occ") << endl
         << "ip             : " << ip_state->FirstChild()->Value() << endl
         << "ip's units     : " << ip_units << endl
         << "Lotz parameters (array):" << endl
         << "ai[charge state] = " << element.Lotz_a[charge_state] << endl
         << "aiqi[charge state] = " << element.Lotz_aq[charge_state] << endl
         << "bi[charge state] = " << element.Lotz_b[charge_state] << endl
         << "ci[charge state] = " << element.Lotz_c[charge_state] << endl
         << "##############################" << endl
         << endl;

    cout << "Name           = " << element.name << endl;
    cout << "Symbol         = " << element.symbol << endl;
    cout << "atomicNumber   = " << element.atomicNumber << endl;
    cout << "Mass           = " << element.mass << endl;
    cout << "next_nghb      = " << element.next_nghb << endl;
    cout << "next_nghb_05   = " << element.next_nghb_05 << endl;
    cout << "max_n          = " << element.max_n << endl;
    cout << "max_l          = " << element.max_l << endl;
    cout << "max_Z          = " << element.max_Z << endl;
    cout << "nb_avail_ips   = " << element.nb_avail_ips << endl;

//     Print_Ips_and_Occupations(element);
}

// **************************************************************
void Print_Ips_and_Occupations(elem_props &element)
{
    const int max_Z = element.max_Z;
    const int max_n = element.max_n;
    const int max_l = element.max_l;
    int index;

    std_cout << "Ips:\n";
    for (int Z = 0 ; Z <= max_Z ; Z++ )
    {
        std_cout << "Z = " << Z << "\n";
        std_cout << "          ";
        for (int l = 0 ; l <= max_l ; l++ )
        {
            std_cout << "l=" << l << "             ";
        }
        std_cout << "\n";

        for (int n = max_n ; n >= 0  ; n-- )
        {
            std_cout << "n="<<n<<"    ";
            for (int l = 0 ; l <= max_l ; l++ )
            {
                index = get_element_index(l, n, Z, max_l, max_n);
                std_cout.Format(8,3,'f'); std_cout << element.Ips[index] << " (" << element.occ[index] << ")    ";
            }
            std_cout << "\n";
        }
        std_cout << "---------------------------------------\n";
    }
}


// **************************************************************
void Allocate_Element_Arrays(elem_props &element)
/**
 * For each Z, there is one "slice":
 *        | l=0 |  1  |  2  |
 *   n=0  | --- | --- | --- |
 *   1    |     | --- | --- |
 *   2    |     |     | --- |
 *   3    |     |     |     |
 *   4    |     |     |     |
 *   5    |     |     |     |
 *          (s)   (p)   (d)
 *
 *
 * "---" are un-allowed states
 * array[l][n][Z] = array[l + n*max_l + Z*max_l*max_n]
 * n between 1 and max_n       (total: max_n)
 * l between 0 and max_n-1     (total: max_l)
 * Because C/C++ arrays start at 0, a column for n=0 will be
 * allocated too, but not used. This will keep code consistent
 */
{
    element.set_pointers_to_null();

    element.occ       = (int *)    calloc((element.max_n+1)*(element.max_l+1)*(element.max_Z+1), sizeof(int));
    element.Ips       = (double *) calloc((element.max_n+1)*(element.max_l+1)*(element.max_Z+1), sizeof(double));
    element.IpsCummul = (double *) calloc((element.max_Z+1), sizeof(double));
    element.IpsLowest = (double *) calloc((element.max_Z+1), sizeof(double));
    element.l         = (int *)    calloc((element.max_Z+1), sizeof(int));
    element.m         = (int *)    calloc((element.max_Z+1), sizeof(int));

    if (
        element.occ == NULL || element.Ips == NULL ||
        element.IpsCummul == NULL ||
        element.IpsLowest == NULL ||
        element.l == NULL || element.m == NULL
        )
    {
        DEBUGP("ERROR: Allocate_Element_Arrays() failed\n");
        std_cout << "Not enough memory?\n";
        std_cout << "max_n = "<<element.max_n<<", max_l = "<<element.max_l<<", max_Z = "<<element.max_Z<<"\n";;
        abort();
    }

    element.Lotz_a  = (double *) calloc(element.max_Z+1, sizeof(double));
    element.Lotz_aq = (double *) calloc(element.max_Z+1, sizeof(double));
    element.Lotz_b  = (double *) calloc(element.max_Z+1, sizeof(double));
    element.Lotz_c  = (double *) calloc(element.max_Z+1, sizeof(double));

    if (element.Lotz_a == NULL || element.Lotz_aq == NULL ||
        element.Lotz_b == NULL || element.Lotz_c  == NULL)
    {
        DEBUGP("ERROR: Allocate_Element_Arrays() for Lotz parameters failed\n");
        std_cout << "Not enough memory?\n";
        std_cout << "max_Z = " << element.max_Z << "\n";
        abort();
    }
}

// **************************************************************
void XML_Get_max_n(TiXmlNode *Z, elem_props &element)
{
    int n;
    element.max_n = 0;
    TiXmlNode *subnode = NULL;
    subnode = Z->IterateChildren(subnode);
    while ( subnode != 0 )
    {
        subnode->ToElement()->QueryIntAttribute("n", &n);
        if (n > element.max_n) element.max_n = n;
        subnode = Z->IterateChildren(subnode);
    }
}

// **************************************************************
void XML_Get_max_l(TiXmlNode *Z, elem_props &element)
{
    int l;
    element.max_l = 0;
    TiXmlNode *subnode = NULL;
    subnode = Z->IterateChildren(subnode);
    while ( subnode != 0 )
    {
        subnode->ToElement()->QueryIntAttribute("l", &l);
        if (l > element.max_l) element.max_l = l;
        subnode = Z->IterateChildren(subnode);
    }
}

// **************************************************************
void XML_Read_Occupied_and_Ips_and_Lotz(TiXmlNode *IPs, elem_props &element)
/**
 * For each Z, there is one "slice":
 *        | l=0 |  1  |  2  |
 *   n=0  | --- | --- | --- |
 *   1    |     | --- | --- |
 *   2    |     |     | --- |
 *   3    |     |     |     |
 *   4    |     |     |     |
 *   5    |     |     |     |
 *          (s)   (p)   (d)
 * "---" are un-allowed states
 * array[l][n][Z] = array[l + n*max_l + Z*max_l*max_n]
 * n between 1 and max_n       (total: max_n)
 * l between 0 and max_n-1     (total: max_l)
 * Because C/C++ arrays start at 0, a column for n=0 will be
 * allocated too, but not used. This will keep code consistent
 */
{
    const int max_Z = element.max_Z;
    const int max_n = element.max_n;
    const int max_l = element.max_l;

    TiXmlNode *charge_state = NULL;
    TiXmlNode *ip = NULL;
    TiXmlNode *FirstOccupiedState = NULL;
    int return_value;
    int index;

    for (int Z = 0 ; Z <= max_Z ; Z++ )
    {
        return_value =
            XML_Get_SubNode_Matching_Attribute(IPs, "z", "z", Z, &charge_state);
        if (return_value == TIXML_SUCCESS)
        {
            // Read Lotz parameters
            element.Lotz_a[Z]  = XML_Get_Double(charge_state, "Lotz/a");
            element.Lotz_aq[Z] = XML_Get_Double(charge_state, "Lotz/aq");
            element.Lotz_b[Z]  = XML_Get_Double(charge_state, "Lotz/b");
            element.Lotz_c[Z]  = XML_Get_Double(charge_state, "Lotz/c");

            for (int n = max_n ; n >= 0  ; n-- )
            {
                for (int l = 0 ; l <= max_l ; l++ )
                {
                    return_value = XML_Get_SubNode_Matching_Attribute(
                        charge_state, "ip", "n", n, "l", l, &ip);
                    if (return_value == TIXML_SUCCESS)
                    {
                        index = get_element_index(l, n, Z, max_l, max_n);

                        element.Ips[index] = atof(ip->FirstChild()->Value());

                        ip->ToElement()->QueryIntAttribute("occ", &(element.occ[index]));
                    }
                }
            }

            // Get the "l" of the first occupied state for each charge states
            // Get the first <ip>
            FirstOccupiedState = charge_state->FirstChild();
            // While the ip is zero, go to next sibling, until we find the first non-zero ip
            while (FirstOccupiedState->FirstChild()->ValueStr() == std::string("0.0"))
            {
                FirstOccupiedState = FirstOccupiedState->NextSibling();
            }
            element.l[Z] = XML_Get_Attribute_Int(FirstOccupiedState, "l");
//             std::cout << "1. FirstOccupiedState = " << FirstOccupiedState->FirstChild()->Value() << std::endl;
//             std::cout << "1. l = " << element.l[Z] << std::endl;
        }
        else
        {
            std_cout << "ERROR: XML_Get_SubNode_Matching_Attribute() failed in XML_Read_Occupied_and_Ips_and_Lotz()\n";
            abort();
        }
    }

    // Calculate cumulative IPs (Z = 0)
    element.IpsCummul[0] = 0.0;
    // Find lowest IP for each charge states (Z = 0)
    index = get_index_lowest_Ip(0, max_l, max_n, element.occ);
    element.IpsLowest[0] = element.Ips[index];
    for (int Z = 1 ; Z <= max_Z ; Z++ )
    {
        index = get_index_lowest_Ip(Z, max_l, max_n, element.occ);

        // Calculate cumulative IPs
        element.IpsCummul[Z] = element.IpsCummul[Z-1] + element.Ips[index];
        // Find lowest IP for each charge states
        element.IpsLowest[Z] = element.Ips[index];
    }
}
// **************************************************************
int XML_Get_SubNode_Matching_Attribute(TiXmlNode *root,
                                         const char *elements,
                                         const char *attribute,
                                         const int attribute_value,
                                         TiXmlNode **subnode)
{
    *subnode = root->FirstChild(elements);

    int int_read = -1;
    do {
        if (
            (*subnode)->ToElement()->QueryIntAttribute(attribute, &int_read)
            != TIXML_SUCCESS
            )
        {
            DEBUGP("ERROR: XML_Get_SubNode_Matching_Attribute() (char) failed\n");
            std_cout << "root: <"<<root->Value()<<"> ("<<root<<"), elements: "<<elements<<", attribute: "<<attribute<<", attribute_value: "<<attribute_value<<"\n";
            abort();
        }
    } while (
        int_read != attribute_value &&
        ((*subnode) = root->IterateChildren(*subnode)) != 0
    );
    if (*subnode == NULL)
        return TIXML_NO_ATTRIBUTE;
    else
        return TIXML_SUCCESS;
}

// **************************************************************
int XML_Get_SubNode_Matching_Attribute(TiXmlNode *root,
                                         const char *elements,
                                         const char *attribute1,
                                         const int attribute1_value,
                                         const char *attribute2,
                                         const int attribute2_value,
                                         TiXmlNode **subnode)
{
    *subnode = root->FirstChild(elements);

    int int_read1 = -1;
    int int_read2 = -1;
    do {
        if (
            (*subnode)->ToElement()->QueryIntAttribute(attribute1, &int_read1)
            != TIXML_SUCCESS
        ||
            (*subnode)->ToElement()->QueryIntAttribute(attribute2, &int_read2)
            != TIXML_SUCCESS
        )
        {
            DEBUGP("ERROR: XML_Get_SubNode_Matching_Attribute() (2 char) failed\n");
            printf("root: <%s> (%p), elements: %s, ", root->Value(), root, elements);
            printf("attribute1: %s, attribute_value1: %d", attribute1, attribute1_value);
            printf(", attribute2: %s, attribute_value2: %d\n", attribute2, attribute2_value);
            printf("(*subnode)->Value() = %s\n", (*subnode)->Value());
            abort();
        }
    } while (
        !(int_read1 == attribute1_value && int_read2 == attribute2_value) &&
        (((*subnode) = root->IterateChildren(*subnode)) != 0) &&
        (strcmp((*subnode)->Value(), elements) == strcmp_success)
    );
    if (*subnode == NULL)
        return TIXML_NO_ATTRIBUTE;
    else
        return TIXML_SUCCESS;
}

// **************************************************************
int XML_Get_SubNode_Matching_Attribute(TiXmlNode *root,
                                         const char *elements,
                                         const char *attribute,
                                         const char *attribute_value,
                                         TiXmlNode **subnode)
{
    // Get the subnode pointed by "elements"
    XML_Get_SubNode(root, elements, subnode);

    // This is the word after the last "/" in the "elements" string
    std::string string_last_element = std::string((*subnode)->Value());

    // *subnode is actually at the "string_last_element" node.
    // We want its parent.
    *subnode = (*subnode)->Parent();

    // Go through all child and find the right one with the matching attribute
    for (TiXmlNode *child = (*subnode)->FirstChild() ; child ; child = child->NextSibling() )
    {
        // Skip anything with wrong value (for example, comments)
        if (std::string(child->Value()) != string_last_element) continue;
        // Check if attribute's value of current child match the wanted one's value
        if ( std::string(child->ToElement()->Attribute(attribute)) == std::string(attribute_value) )
            *subnode = child;
    }

    if (*subnode == NULL)
        return TIXML_NO_ATTRIBUTE;
    else
        return TIXML_SUCCESS;
}

// **************************************************************
void XML_SplitString(const std::string &to_split,
                     const char delimiter,
                     std::vector<std::string> &split_strings)
{
    split_strings.clear();

    // Find first delimiter
    size_t slash_pos0 = 0;
    // Find next delimiter character
    size_t slash_pos1 = to_split.find(delimiter);

    // Search string only if it contains a delimiter character
    while ( slash_pos1 != string::npos )
    {
        // Add the substring to the vector, omitting the delimiter
        split_strings.push_back(to_split.substr(slash_pos0, slash_pos1-slash_pos0));

        slash_pos0 = slash_pos1+1;
        slash_pos1 = to_split.find(delimiter, slash_pos0);
    }

    // The last substring (or the only one) is always skipped, so add it here
    split_strings.push_back(to_split.substr(slash_pos0, slash_pos1-slash_pos0));
}

// **************************************************************
void XML_Get_SubNode(TiXmlNode *RootNode, const char *celements, TiXmlNode **subnode)
{
    // Temporary node
    *subnode = RootNode;

    // Split the XML path string into many substrings, saved in a vector
    std::vector<std::string> subelements;
    XML_SplitString(std::string(celements), '/', subelements);

    for (vector<std::string>::iterator it = subelements.begin() ; it < subelements.end() ; it++ )
    {
        // For each substrings, get the first child
        *subnode = (*subnode)->FirstChild(it->c_str());
    }
}

// **************************************************************
void XML_Get_Characters(TiXmlNode *root, const char *elements, char *buff)
{
    // Maximum number of characters to copy to strings. -2 to be sure that
    // enough space is left for null characters (\0) and such.
    const unsigned int mc = 100-2;

    TiXmlNode *subnode;
    XML_Get_SubNode(root, elements, &subnode);
    if (subnode != NULL)
        strncpy(buff, subnode->FirstChild()->Value(), mc);
    else
        strncpy(buff, "0", mc);
}

// **************************************************************
int XML_Get_Attribute_Int(TiXmlNode *root, const char *attribute)
{
    int read_attribute = -1;
    if (
        root->ToElement()->QueryIntAttribute(attribute, &read_attribute)
        != TIXML_SUCCESS
        )
    {
        DEBUGP("ERROR: XML_Get_Attribute_Int() failed\n");
        printf("root: <%s> (%p), attribute: %s\n",
                root->Value(), root, attribute);
        abort();
    }
    return read_attribute;
}

// **************************************************************
double XML_Get_Attribute_Double(TiXmlNode *root, const char *attribute)
{
    double read_attribute = -1.0;
    if (
        root->ToElement()->QueryDoubleAttribute(attribute, &read_attribute)
        != TIXML_SUCCESS
        )
    {
        DEBUGP("ERROR: XML_Get_Attribute_Double() failed\n");
        printf("root: <%s> (%p), attribute: %s\n",
                root->Value(), root, attribute);
        abort();
    }
    return read_attribute;
}

// **************************************************************
void XML_Get_Attribute_Char(TiXmlNode *root, const char *attribute, char *read_attribute)
{
    strncpy(read_attribute,root->ToElement()->Attribute(attribute),98);
}

// **************************************************************
bool XML_Get_Bool(TiXmlNode *root, const char *elements)
{
    char temp[100];
    XML_Get_Characters(root, elements, temp);

    bool return_value;

    if      (strcmp(temp, "yes") == strcmp_success || strcmp(temp, "on")  == strcmp_success)
        return_value = true;
    else if (strcmp(temp, "no")  == strcmp_success || strcmp(temp, "off") == strcmp_success)
        return_value = false;
    else
    {
        DEBUGP("");
        printf("Error intepreting boolean value of '%s'\n", elements);
        printf("String read was '%s'\n", temp);
        abort();
    }

    return return_value;
}

// **************************************************************
int XML_Get_Int(TiXmlNode *root, const char *elements)
{
    char temp[100];
    XML_Get_Characters(root, elements, temp);
    return atoi(temp);
}

// **************************************************************
long int XML_Get_LInt(TiXmlNode *root, const char *elements)
{
    char temp[100];
    XML_Get_Characters(root, elements, temp);
    return atol(temp);
}

// **************************************************************
uint64_t XML_Get_UInt64(TiXmlNode *root, const char *elements)
{
    char temp[100];
    XML_Get_Characters(root, elements, temp);
    return uint64_t(atof(temp));
}

// **************************************************************
int64_t  XML_Get_Int64(TiXmlNode *root, const char *elements)
{
    char temp[100];
    XML_Get_Characters(root, elements, temp);
    return int64_t(atof(temp));
}

// **************************************************************
double XML_Get_Double(TiXmlNode *root, const char *elements)
{
    char temp[100];
    XML_Get_Characters(root, elements, temp);
    return atof(temp);
}

// **************************************************************
int XML_Count_Elements(TiXmlNode *root, const char *element)
{
    int count = 0;

    // The pointer needs to be null initially for IterateChildren()
    // to work.
    TiXmlNode *subnode = NULL;
    subnode = root->IterateChildren(subnode);
    while ( subnode != 0 )
    {
        // If the name of the subnode is really the element we want
        // to count, increment the counter.
        if (strcmp(subnode->Value(), element) == strcmp_success)
            count++;
        // Then go to next children of the parent
        subnode = root->IterateChildren(subnode);
    }
    return count;
}

// ********** End of file ***************************************

/****************************************************************

    General functions

****************************************************************/

#ifdef __SUNPRO_CC
#include <string.h>
#else
#include <cstring>
#endif

#include <iostream>
#include <cstdlib>
#include <cstdio>
#include <cstring>
#include <cassert>
#include <cfloat>
#include <climits> // CHAR_BIT
#include <stdint.h> // (u)int64_t

#include "Constants.hpp"
#include "General.hpp"
#include "Potentials.hpp"
#include "NR.hpp"
#include "Global.hpp"
#include "data/ImpactCrossSections_Xe_Load.hpp"
#include "data/ImpactCrossSections_Ar_Load.hpp"
#include "Std_Cout.hpp"

// Is the library initialized?
int is_initialized = -1;

int CALLED_FROM;
int POTENTIALSHAPE;

int id_of_next_electron;

// MPI information
int mpi_rank, mpi_size;

// Do we need to use ghost?
bool use_ghost;

const int IonizationLib_SVN_rev = IONIZATION_LIBRARY_SVN_REVISION;

// If output is needed, where to do it?
char lib_io_basename[lib_max_string_size];

// Error function lookup table
// erf(R)
double *tl_erf;             // Table
const int    tl_n = 200;    // Number of points of the lookup table
const double tl_Rmax = 4.0; // Maximum value of R: erf(4) = 0.999999984582742
const double tl_dR = tl_Rmax / (tl_n-1); // Step
const double tl_one_over_dR = 1.0 / tl_dR;
//
void initialize_erf_lookup_table();

// **************************************************************
// ********** Accessible functions implementations **************
// **************************************************************

void Check_if_initialized(void)
{
#ifdef YDEBUG
    if (!is_initialized)
    {
        DEBUGP("ERROR!!!\n");
        std_cout << "is_initialized = " << (is_initialized ? "yes" : "no") << "\n";
        std_cout << "Library is not initialized, please call Ionization_Initialize()\n";
        std_cout << "Exiting\n";
        abort();
    }
#endif
}

// **************************************************************
void Set_id_of_next_electron(const int &id)
{
    id_of_next_electron = id;
}
// **************************************************************
int Get_id_of_next_electron()
{
    return id_of_next_electron;
}

// Compare two numbers. If their relative difference is
// bigger than a certain precision (1e-14) then assert
// (exit with error)
void assert_diff(double a, double b)
{
    if ((a+b) > DBL_MIN)
        assert((fabs( (a-b) / (a+b) )) <= 1.0e-14);
}

// **************************************************************
void Ionization_Initialize_IO(const std::string io_basename)
{
    strncpy(lib_io_basename, io_basename.c_str(), lib_max_string_size-1);
    lib_io_basename[lib_max_string_size-1] = '\0';
    std_cout << "If library needs to output data, it will do so in:\n";
    std_cout << lib_io_basename << "\n";
}

// **************************************************************
void Ionization_Initialize(
        const int arg_called_from,
        const int input_sg_m,
        const double input_s_rmin,
        const int Nb_particles,
        const bool using_ghost,
        const int arg_mpi_rank, const int arg_mpi_size,
        const char potential_shape[],const elem_props &element, const double base_potential_depth)
{

    is_initialized = true;

    mpi_rank = arg_mpi_rank;
    mpi_size = arg_mpi_size;

    use_ghost = using_ghost;

    CALLED_FROM = arg_called_from;
    Set_id_of_next_electron(Nb_particles);

    base_pot_well_depth = base_potential_depth; //in eV

    Potentials_Set_Parameters = NULL;
    Calculate_Potential       = NULL;
    Set_Field                 = NULL;

    if (mpi_rank == 0)
    {
        std_cout << "###############################################\n";
        std_cout << "### Ionization library initialization...    ###\n";
        std_cout << "###############################################\n";
        std_cout << "### Using ghost: " << (use_ghost ? "yes" : "no ") << "                        ###\n";
    }

    if (strcmp(potential_shape, "PureCoulomb") == strcmp_success)
    {
        POTENTIALSHAPE = Potential_Shapes_Simple;
        double r_temp = 0.0;
        if (mpi_rank == 0)
            std_cout << "### Using a pure Coulomb interaction        ###\n";
        Initialize_Simple(r_temp);

        Potentials_Set_Parameters = &Potentials_Set_Parameters_Simple;
        Calculate_Potential       = &Calculate_Potential_Cutoff_Simple;
        Set_Field                 = &Set_Field_Cutoff_Simple;
    }
    else if (strcmp(potential_shape, "Simple") == strcmp_success)
    {
        POTENTIALSHAPE = Potential_Shapes_Simple;
        if (mpi_rank == 0)
        {
            std_cout << "### Using a simple cutoff                   ###\n";
            std_cout << "### for close range interaction             ###\n";
        }
        Initialize_Simple(input_s_rmin);

        Potentials_Set_Parameters = &Potentials_Set_Parameters_Simple;
        Calculate_Potential       = &Calculate_Potential_Cutoff_Simple;
        Set_Field                 = &Set_Field_Cutoff_Simple;
    }
    else if (strcmp(potential_shape, "Harmonic") == strcmp_success)
    {
        if (mpi_rank == 0)
        {
            std_cout << "### Using an harmonic potential             ###\n";
            std_cout << "### for close range interaction             ###\n";
        }
        POTENTIALSHAPE = Potential_Shapes_Harmonic;

        Potentials_Set_Parameters = &Potentials_Set_Parameters_Harmonic;
        Calculate_Potential       = &Calculate_Potential_Cutoff_Harmonic;
        Set_Field                 = &Set_Field_Cutoff_Harmonic;
    }
    else if (strcmp(potential_shape, "SuperGaussian") == strcmp_success)
    {
        if (mpi_rank == 0)
        {
            std_cout << "### Using a super-gaussian potential        ###\n";
            std_cout << "### for close range interaction             ###\n";
            std_cout << "### with m = " << input_sg_m << "\n";
        }
        POTENTIALSHAPE = Potential_Shapes_SuperGaussian;
        Initialize_SuperGaussian(input_sg_m);

        Potentials_Set_Parameters = &Potentials_Set_Parameters_SuperGaussian;
        Calculate_Potential       = &Calculate_Potential_Cutoff_SuperGaussian;
        Set_Field                 = &Set_Field_Cutoff_SuperGaussian;
    }
    else if (strcmp(potential_shape, "GaussianDistribution") == strcmp_success)
    {
        if (mpi_rank == 0)
        {
            std_cout << "### Using a gaussian charge distribution    ###\n";
            std_cout << "### potential for close range interaction   ###\n";
        }
        POTENTIALSHAPE = Potential_Shapes_GaussianDistribution;
        initialize_erf_lookup_table();

        Potentials_Set_Parameters = &Potentials_Set_Parameters_GaussianDistribution;
        Calculate_Potential       = &Calculate_Potential_Cutoff_GaussianDistribution;
        Set_Field                 = &Set_Field_Cutoff_GaussianDistribution;
    }
    else if (strcmp(potential_shape, "HermanSkillman") == strcmp_success)
    {
        if (mpi_rank == 0)
        {
            std_cout << "### Using the Herman-Skillman (HS) potential ##\n";
            std_cout << "### for close range interaction             ###\n";
            std_cout << "### and Super-Gaussian for electrons and 8+ ###\n";
            std_cout << "### and up ions (m = " << input_sg_m << ")                    ###\n";
        }
        POTENTIALSHAPE = Potential_Shapes_HS_SuperGaussian;
        Initialize_HS(input_sg_m, input_s_rmin);

        Potentials_Set_Parameters = &Potentials_Set_Parameters_HS_SuperGaussian;
        Calculate_Potential       = &Calculate_Potential_Cutoff_Harmonic;
        Set_Field                 = &Set_Field_Cutoff_HS_SuperGaussian;
    }
    else if (strcmp(potential_shape, "Symmetric") == strcmp_success)
    {
        if (mpi_rank == 0)
        {
            std_cout << "### Using the symmetric two charge          ###\n";
            std_cout << "### distribution interaction                ###\n";
        }
        POTENTIALSHAPE = Potential_Shapes_ChargeDistribution_Symmetric;
        initialize_erf_lookup_table();

        Potentials_Set_Parameters = &Potentials_Set_Parameters_ChargeDistribution_Symmetric;
        Calculate_Potential       = &Calculate_Potential_Cutoff_ChargeDistribution_Symmetric;
        Set_Field                 = &Set_Field_Cutoff_ChargeDistribution_Symmetric;
    }
    else if (strcmp(potential_shape, "ScreenedCoulomb") == strcmp_success)
    {
        if (mpi_rank == 0)
        {
            std_cout << "### Using the Coulomb potential screened with##\n";
            std_cout << "### parameter alpha = " << sc_alpha * m_to_angstrom << "                 ###\n";
        }
        POTENTIALSHAPE = Potential_Shapes_ScreenedCoulomb;

        Potentials_Set_Parameters = &Potentials_Set_Parameters_ScreenedCoulomb;
        Calculate_Potential       = &Calculate_Potential_Cutoff_ScreenedCoulomb;
        Set_Field                 = &Set_Field_Cutoff_ScreenedCoulomb;
    }
    else
    {
        if (mpi_rank == 0)
        {
            DEBUGP("### ERROR\n");
            std_cout << "    ### Ionization_Initialize() called without a:\n";
            std_cout << "    ### valid potential shape (" << potential_shape << ")\n";
            std_cout << "    ### Exiting\n";
            abort();
        }
    }

    //Load the necessary table for excitation cross-sections
    heap_load_of_excitation_xsections(element);

    // FIXME: Adapt "called from"
//     if (Lib_Get_Code_Called_From() == CODE_PIC3D)
//     {
//         if (mpi_rank == 0) std_cout << "### Called from : PIC3D   ";
//     }
//     else if (Lib_Get_Code_Called_From() == CODE_TREECODE)
//     {
//         if (mpi_rank == 0) std_cout << "### Called from : TREECODE";
//     }
//     else
//     {
//         if (mpi_rank == 0)
//         {
//             std_cout << "### ERROR:\n";
//             std_cout << "### Called from NOTHING\n";
//             std_cout << "### EXITING\n";
//             abort();
//         }
//     }
    if (mpi_rank == 0)
    {
        //std_cout << " (" << Lib_Get_Code_Called_From() << ")              ###\n";
        std_cout << "### Library's Subversion's revision: " << Lib_Get_SVN_Revision() << "   ###\n";
        std_cout << "### Ionization library initialization done. ###\n";
        std_cout << "###############################################\n";
    }
}

// **************************************************************
void Ionization_Finalize(elem_props &element)
{
    free(tl_erf);

    // Free the impact excitation cross sections
    // 1st the 8 charge states neutral to 7+
    const int num_charge_st = 8;
    for (int i = 0 ; i < num_charge_st ; i++)
    {
        for (int j = 0 ; j < Nb_excited_states_total ; j++)
        {
            // 3rd, allocate memmory for the xsection for the excited state of this charge state
            free_me(impact_xsec_GSES[i][j]);
            free_me(impact_xsec_ESIS[i][j]);
        }
        // 2nd, allocate the memmory for each excited state
        free_me(impact_xsec_GSES[i]);
        free_me(impact_xsec_ESIS[i]);

    }
    free_me(impact_xsec_GSES);
    free_me(impact_xsec_ESIS);

    element.free_arrays();
}

// **************************************************************
int Lib_Get_SVN_Revision()
{
    return IonizationLib_SVN_rev;
}

// **************************************************************
int Lib_Get_Code_Called_From()
{
    Check_if_initialized();
    return CALLED_FROM;
}

// **************************************************************
int Lib_Get_Pontential_Shape()
{
    Check_if_initialized();
    return POTENTIALSHAPE;
}

// **************************************************************
int Lib_Get_Rank()
{
    Check_if_initialized();
    return mpi_rank;
}

// **************************************************************
int Lib_Get_Size()
{
    Check_if_initialized();
    return mpi_size;
}

// **************************************************************
bool Lib_Get_UseGhost()
{
    Check_if_initialized();
    return use_ghost;
}

char* Lib_Get_IOBasename()
{
    return lib_io_basename;
}

// **************************************************************
void Error(const char msg[])
{
    std::cout
        << "###############################################" << std::endl
        << "ERROR:" << std::endl
        << "      " << msg << std::endl
        << "Exiting." << std::endl
        << "###############################################" << std::endl;
    abort();
}

// **************************************************************
void initialize_erf_lookup_table()
{
    tl_erf = (double *) calloc_and_check(tl_n, sizeof(double));
    if (tl_erf == NULL)
    {
        std_cout << "Allocationg for tl_erf failed!\nAborting.\n";
        abort();
    }
    // Populating the lookup table
    for (int i = 0 ; i < tl_n ; i++)
    {
        tl_erf[i] = nr::int_erf(i*tl_dR);
    }
}

// **************************************************************
int factorial(int x)
/**
 * Calculate the factorial of a number.
 */
{
    if ( x == 1 || x == 0 ) return 1;
    else if (x < 0)
    {
        Error("Call of function \"int factorial(int x)\" with negative value.");
    }

    int res = 1;
    for (int i = 2 ; i <= x ; i++) res *= i;

    return res;
}

// **************************************************************
double factoriald(int x)
{
    return double(factorial(x));
}

// **************************************************************
double my_erf(double x)
{
    double erf_value = 0.0;
    //erf_value = nr::int_erf(x);
    //erf_value = erf(x);
    //erf_value = nr::erff(x);
    //erf_value = nr::python_erf(x);
    //erf_value = gsl_sf_erf (x);
    if (x < tl_Rmax)
    {
        const int base = int(x * tl_one_over_dR);
        const double gain = double(x * tl_one_over_dR) - double(base);
        erf_value = tl_erf[base] * (1.0 - gain) + gain*tl_erf[base+1];
    } else {
        erf_value = 1.0;
    }

    return erf_value;
}

// **************************************************************
template <class Integer>
void Lib_Print_Integer_in_Binary(Integer n)
/**
 * Prints binary representation of an integer if any size.
 * Inspired by http://www.exploringbinary.com/displaying-the-raw-fields-of-a-floating-point-number/
 * WARNING: In C/C++, logical right shift of SIGNED integers is compiler dependant. GCC keeps the
 *          sign bit intact (instead of putting a 0).
 *          So ">>" is an arithmetic shift when the integer is signed. Unsigned are not
 *          affected (arithmetic and logical shifts are the same for unsigned integers).
 *          See http://en.wikipedia.org/wiki/Bitwise_operation#Arithmetic_shift
 */
{
                                        // Example 32 bits integers, converted from
                                        // http://www.binaryconvert.com/convert_unsigned_int.html
    const Integer zero  =  Integer(0);  // 00000000 00000000 00000000 00000000
    //const Integer ones  = ~zero;        // 11111111 11111111 11111111 11111111
    const Integer one   =  Integer(1);  // 00000000 00000000 00000000 00000001
    //const Integer two   =  Integer(2);  // 00000000 00000000 00000000 00000010
    //const Integer eigth =  Integer(8);  // 00000000 00000000 00000000 00001000
    const Integer nb_bits_per_byte    = CHAR_BIT; // Normaly, it is 8, but could be different.
    const Integer nb_bits_per_Integer = sizeof(n)*nb_bits_per_byte;

    // Starting from the LSB being index "0", the MSB is at index "msb_position"
    const Integer msb_position  = nb_bits_per_Integer - one;
    const Integer msb           = one << msb_position;
    const Integer or_msb        = ~msb;

    // Note that right shifting a signed integer migth keep the sign bit intact
    // (instead of setting it to 0) because C/C++ is implementation dependant
    // regarding right shift applied to negative signed integers. GCC will do
    // an "arithmetic right shift", meaning dividing the integer by 2. This will
    // keep the number negative (if it was). Because of this, the mask can get
    // screwed. If the Integer type is signed, first right shifting of the
    // mask of one (having an initial value of "msb" == 10000... and thus a
    // negative value) will keep the sign bit (leading to mask == 11000...) but
    // what we want is just to move the mask's bit, not keep the integer
    // reprentation "valid" (we want mask == 01000...). To fix that, after
    // right shifting the mask by one, we "AND" it (using "&") with "or_msb"
    // (or_msb == 01111...) to make sure we forget the sign bit.
    for (Integer mask = msb ; mask != zero ; mask = ((mask >> one) & or_msb ))
    {
        // If "n"'s bit at position of the mask is 0, print 0, else print 1.
        if ((mask & n) == zero) std_cout << "0";
        else                    std_cout << "1";
    }
}


// **************************************************************
void Lib_Print_Double_in_Binary(double d)
/**
 * Prints binary representation of a double
 * http://www.exploringbinary.com/displaying-the-raw-fields-of-a-floating-point-number/
 */
{
    uint64_t *double_as_int = (uint64_t *) &d;
    const int bit_size = CHAR_BIT*sizeof(uint64_t);

    // Print bits by bits
    for (int b = 0 ; b <= bit_size-1 ; b++)
    {
        if (b == 1)
            std_cout << " ";    // Space after sign field
        if (b == 12)
            std_cout << " ";    // Space after exponent field

        // Get bit, but in reverse order. On Little Endian machines
        // (most of Intel and such), the byte with lower address
        // is the less significant. Since we want to print from
        // the most significant, we iterate from the end.
        if ((*double_as_int >> ((bit_size-1)-b)) & 1)
            std_cout << "1";
        else
            std_cout << "0";
    }
    //std_cout << "\n";
}

// **************************************************************
void heap_load_of_excitation_xsections(const elem_props &element)
/**
 * The cross sections have been calculated externally and are
 * used as a lookup table. But since the size of the array is
 * big (and in 3D), it needs to be allocated on the heap and not
 * on the stack (there is no room on the stack for that). It is
 * done here.
 */
{
    // We are only going to 10+ for now
    const int num_charge_st = number_of_excited_charge_states;

    // The number of entries for each cross-section
    // Allocate the memory on the heap
    impact_xsec_GSES = (double ***) calloc_and_check(num_charge_st,
                                                    sizeof(double ***),
                                                    "impact_xsec_GSES[]");

    // 1st the 8 charge states neutral to 7+
    for (int i = 0 ; i < num_charge_st ; i++)
    {
        // 2nd, allocate the memmory for each excited state
        impact_xsec_GSES[i] = (double **) calloc_and_check(Nb_excited_states_total,
                                                          sizeof(double **),
                                                          "impact_xsec_GSES[][]");

        for (int j = 0 ; j < Nb_excited_states_total ; j++)
        {
            // 3rd, allocate memmory for the xsection for the excited state of this charge state
            impact_xsec_GSES[i][j] = (double  *) calloc_and_check(es_num_elements,
                                                                 sizeof(double),
                                                                 "impact_xsec_GSES[][][]");
        }
    }

    // The number of entries for each cross-section
    // Allocate the memory on the heap
    impact_xsec_ESIS = (double ***) calloc_and_check(num_charge_st,
                                                    sizeof(double ***),
                                                    "impact_xsec_ESIS[]");

    // 1st the 8 charge states neutral to 7+
    for (int i = 0 ; i < num_charge_st ; i++)
    {
        // 2nd, allocate the memmory for each excited state
        impact_xsec_ESIS[i] = (double **) calloc_and_check(Nb_excited_states_total,
                                                          sizeof(double **),
                                                          "impact_xsec_ESIS[][]");

        for (int j = 0 ; j < Nb_excited_states_total ; j++)
        {
            // 3rd, allocate memmory for the xsection for the excited state of this charge state
            impact_xsec_ESIS[i][j] = (double  *) calloc_and_check(es_num_elements,
                                                                 sizeof(double),
                                                                 "impact_xsec_ESIS[][][]");
        }
    }

    // Load the lookup tables into the array impact_xsec_GSES and impact_es_xsec
    if (element.atomicNumber ==54)
      ImpactCrossSections_Xe_Load(es_num_elements);
    else if (element.atomicNumber ==18)
      ImpactCrossSections_Ar_Load(es_num_elements);
    else
    {
      std::cout << "Unknown element for lookup tables for excitation. Aborting" << std::endl;
      std::cout << "Unknown element for lookup tables for excitation. Setting all to 0"
                << " i.e. there will be no excitation." << std::endl;
      //abort();
    }

}

// ********** End of file ***************************************


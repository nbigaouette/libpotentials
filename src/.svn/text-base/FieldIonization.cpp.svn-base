/****************************************************************

    Routines for field ionization

    Important references:
        Tree code

    Goal:
        In the potential of the cluster the ionization potential
        changes. This is evident iof we look at the Schrodinger
        Equation for a sole atomic system (in atomic units, where
        V_1 is the potential between an electron and the nucleus)
        (del^2 + V_1) Phi_i = E_i  Phi_i
        vs the equation inside a cluster potential (Given by V_2
        and assumed to be constant)
        (del^2 + V_1 + V_2) Phi_i = E_i  Phi_i
        =>  (del^2 + V_1 ) Phi_i = (E_i-V_2)  Phi_i
        Thus it is possible that (E_i-V_2) > 0 resulting in
        ionization due to the cluster field (called field
        ionization here).

    Author: Edward Ackad,,, <eddie@gmail.com>, (C) 2008

****************************************************************/

#ifdef __SUNPRO_CC
#include <stdio.h>
#include <float.h>
#include <stdlib.h>
#include <assert.h>
#else
#include <cstdio>
#include <cfloat>
#include <cstdlib>
#include <cassert>
#endif


#include "FieldIonization.hpp"

// **************************************************************
// ********** Accessible functions implementations **************
// **************************************************************

int Ionization_Field(
        void *al, void *el,
        const int t, const double dt,
        const int &Nb_atoms, const int &Nb_atoms_max,
        int &Nb_electrons, const int &Nb_electrons_max,
        unsigned long int &index_next_empty_space,
        elem_props &element,
        bool &did_ionization_occur
)
{
/*
    int     charge_state;
    double  Ip_au;

    void *ion;

    //for (void *ion = al ; ion < al + Nb_atoms ; ion++)
    for (int i = 0 ; i < Nb_atoms ; i++)
    {
        ion = get_voidp(al, i);

        // "continue" statements stop work on current ion
        // and continue on next one.

        // Ionization is not allowed yet
        if (t < Get_NextIon(ion)) continue;

        charge_state = Get_Charge_State(ion);

        // Change the Ip to be the effective Ip in the
        // cluster potential. Do this by obtaining the potential
        // at the corresponding ghost.
        //bodyptr ghost = ion + Nb_atoms_max + Nb_electrons_max;
        void *ghost = get_voidp(al, i + Nb_atoms_max + Nb_electrons_max);
        Ip_au = (element.IpsLowest[charge_state] - Get_Potential(ghost))*eV_to_Eh;

        // Test if the cluster potential has lowered the atomic
        // potential sufficiently for the electron to become unbound
        if (Ip_au  > 0.0) continue; // electron still bound: continue

       // FIXME: Check new distance of single-photon ionized electrons
        double new_e_distance = a0;
        // Check if particle is too close or to far away from ion
        double dmin = 0.1 * a0;
        double dmax = element.next_nghb_05;
        if( new_e_distance > dmax ) new_e_distance = dmax;
        if( new_e_distance < dmin ) new_e_distance = dmin;

        // Field ionization occurred !!!
        if (Lib_Get_Rank() == 1)
            std_cout << "field ionization occurred! it="<<t<<" id="<<Get_Id(ion)<<"\n";
        did_ionization_occur = 1;

        // Set the direct of the created electron to be towards
        // the closest ion
        double closest_ion_dir[3];
        double closest_ion_mag,distance, inv_distance;
        void * closest_ion = get_voidp(al, Get_ClosestIon(ion));
        set_vector_between_particles(
            Get_Position(ion), Get_Position(closest_ion),
        closest_ion_dir,closest_ion_mag,distance, inv_distance);

//         Create_Electron(
//             el, ion, closest_ion_dir,
//             t, dt, new_e_distance,
//             Nb_atoms, Nb_atoms_max,
//             Nb_electrons, Nb_electrons_max,
//             index_next_empty_space,
//             element,
//             "Create_Electron() called from Ionization_Field() in library"
//         );
        std_cout << "FIXME: Adapt API for Create_Electron() in Ionization_Field()\n";
        abort();

        // The ion cannot be re-ionized for 200 as
        int new_ni = t + (int)ceil(200E-18/dt);
        if( new_ni > Get_NextIon(ion) ) Set_NextIon(ion, new_ni);

        // The newly created electron located
        // at (index_first_empty_space-1) must be set at a specific
        // velocity to match the kinetic energy of the absorbed photon.
//         void *nce = el + index_next_empty_space - 1;

        // Calculate the change in the total energy of the system
        // due to the new charge. Only valid when the electron-ion
        // distance is far enough that the potential at that
        // point is Coulombic. Otherwise there is an asymetry
        // because the one particle sees a distribution but is
        // then treated as a point particle.
    }
  */
    return EXIT_SUCCESS;

}


// ********** End of file ***************************************
